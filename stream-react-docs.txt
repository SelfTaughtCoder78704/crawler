Recording in progress notification

The RecordingInProgressNotification component is based on Notification component that is a simple popover. The SDK attaches the component to RecordCallButton. The popover rendering is controlled by detecting if there is a recording in progress, useToggleCallRecording().

Feedback
General usage
â€‹

The component is used by wrapping the component to which it will refer:

<RecordingInProgressNotification>
  <RecordCallButton />
</RecordingInProgressNotification>

Feedback
Props
â€‹
Name	Type	Default
text	string | undefined	'Recording in progress...'

Text message displayed by the notification.

Feedback
Customization
â€‹

To learn more about the recording functionality, have a look at our call-controls.

Feedback
Previous
Reaction
Next
Speaking while muted notification
Did you find this page helpful?
Section:
Recording in progress notification
SUBMIT
General usage
Props
Customization

Permission notification

The default component used to display permission grant notifications is based on Notification component. It is just a popover displaying text. The text displayed is customisable.

Feedback
General usage
â€‹

The PermissionNotification component is used by some call controls buttons. Here we demonstrate, how it can be used in a button that toggles the audio:

import {
  OwnCapability,
  PermissionNotification,
  Restricted,
  useRequestPermission,
  useCallStateHooks,
} from '@stream-io/video-react-sdk';
import MyIcon from '../Icon';

export type ToggleAudioPublishingButtonProps = {
  // props ...
};

export const ToggleAudioPublishingButton = (
  props: ToggleAudioPublishingButtonProps,
) => {
  const { hasPermission, requestPermission, isAwaitingPermission } =
    useRequestPermission(OwnCapability.SEND_AUDIO);

  const { useMicrophoneState } = useCallStateHooks();
  const { microphone } = useMicrophoneState();

  return (
    <Restricted requiredGrants={[OwnCapability.SEND_AUDIO]}>
      <PermissionNotification
        permission={OwnCapability.SEND_AUDIO}
        isAwaitingApproval={isAwaitingPermission}
        messageApproved="You can now speak."
        messageAwaitingApproval="Awaiting for an approval to speak."
        messageRevoked="You can no longer speak."
      >
        <MyButton
          onClick={async () => {
            if (!hasPermission) {
              await requestPermission();
            } else {
              await microphone.toggle();
            }
          }}
        >
          <MyIcon />
        </MyButton>
      </PermissionNotification>
    </Restricted>
  );
};

Feedback
Props
â€‹
isAwaitingApproval
â€‹
Type
boolean

Set this to true if there is ongoing request for the permission.

messageApproved
â€‹
Type
string

The message to display in the notification once the requested permission is granted.

messageRevoked
â€‹
Type
string

The message to display in the notification once a permission is revoked.

messageAwaitingApproval
â€‹
Type
string

The message to display in the notification while the requested permission is awaiting approval.

permission
â€‹
Type
OwnCapability

The permission for which the notification is displayed.

visibilityTimeout
â€‹
Type	Default
number | undefined	3500

The time in milliseconds to display the notification. Defaults to 3500ms.

Feedback
Customization
â€‹

To learn more about creating custom permission requests listings, have a look at our permission requests customization guide.

Feedback
Previous
Dropdown select
Next
Permission requests
Did you find this page helpful?
Section:
Permission notification
SUBMIT
General usage
Props
isAwaitingApproval
messageApproved
messageRevoked
messageAwaitingApproval
permission
visibilityTimeout
Customization

Dropdown select

The DropDownSelect utility component can be used to to simply create a dropdown select component.

Props
â€‹
Name	Description	Type
icon	Icon to be shown next to the label of the selected item	string | undefined
defaultSelectedLabel	Label to be shown on default	string
defaultSelectedIndex	Sets the default selected option	number
handleSelect	Handler to handle the selected option	(index: number) => void
children	DropDownSelectOption	ReactElement<DropDownSelectOptionProps> | ReactElement<DropDownSelectOptionProps[]>
DropDownSelectOptionProps
â€‹

You can provide the DropdownSelectOption as a child to the DropdownSelect

Name	Description	Type
label		string
selected		boolean | undefined
icon		string
Feedback
Previous
Call statistics
Next
Permission notification
Did you find this page helpful?
Section:
Dropdown select
SUBMIT

Call statistics

The SDK's default component to display statistics about a call is called CallStats. It displays:

Call Latency graph that outlines average round trip time (in ms).
Call Performance section that displays the below listed call statistics
The call statistics displayed:
â€‹
Region - the server we are connected to
Latency - the time it takes to deliver the data between the server and the app
Receive jitter - the variation in the delay of receiving packets of data over a network
Publish jitter - the variation in the delay of sending packets of data over a network
Publish resolution - video resolution we are publishing
Publish quality drop reason - optional explanation of the reason, why the video image quality we are sending has diminished
Receiving resolution - video resolution we are receiving
Receive quality drop reason - optional explanation of the reason, why the video image quality we are receiving has diminished
Publish bitrate - the rate at which data is transmitted from the app to the server
Receiving bitrate - the rate at which data is transmitted from the server to the app
Feedback
General usage
â€‹

The default component is just rendered without passing any props:

const MyCallStats = () => {
  // omitted code ...

  return (
    /* omitted code ... */
    <CallStats />
    /* omitted code ... */
  );
};

Feedback
Props
â€‹

None

Feedback
Customization
â€‹

You can create your own call statistics component using the SDK's call state hooks.

Feedback
Previous
Avatar
Next
Dropdown select
Did you find this page helpful?
Section:
Call statistics
SUBMIT
The call statistics displayed:
General usage
Props
Customization

Device settings

The SDK's default implementation of device settings components consists of audio and video device selectors. These are:

DeviceSelectorVideo
DeviceSelectorAudioInput
DeviceSelectorAudioOutput

There is also a composing component DeviceSettings putting these together.

Default device settings panel
Default camera device selector
Default audio input device selector
Default audio output device selector
Feedback
General usage
â€‹
import { Call, DeviceSettings, StreamCall } from '@stream-io/video-react-sdk';

const MyDevicePanel = () => {
  let call: Call;

  return (
    <StreamCall call={call}>
      <DeviceSettings />
    </StreamCall>
  );
};


Or use the components individually:

import {
  Call,
  DeviceSelectorAudioInput,
  DeviceSelectorVideo,
  StreamCall,
} from '@stream-io/video-react-sdk';

const MyDevicePanel = () => {
  let call: Call;

  return (
    <StreamCall call={call}>
      <DeviceSelectorVideo />
      <DeviceSelectorAudioInput />
    </StreamCall>
  );
};

Feedback
Props
â€‹
DeviceSettings
â€‹
Name	Description	Type	Default
visualType	Visually display a list or dropdown selector	list | dropdown | undefined	list
DeviceSelectorVideo
â€‹
Name	Description	Type	Default
title	Title is displayed at the top of the selector component	string | undefined	Select a Camera
visualType	Visually display a list or dropdown selector	list | dropdown | undefined	list
DeviceSelectorAudioInput
â€‹
Name	Description	Type	Default
title	Title is displayed at the top of the selector component	string | undefined	Select a Mic
visualType	Visually display a list or dropdown selector	list | dropdown | undefined	list
DeviceSelectorAudioOutput
â€‹
Name	Description	Type	Default
title	Title is displayed at the top of the selector component	string | undefined	Select a Speaker
visualType	Visually display a list or dropdown selector	list | dropdown | undefined	list
Feedback
Customization
â€‹

If you want to create your own component, you can make use of Devices Management API to list and select devices.

Feedback
Previous
Participants list
Next
Video preview
Did you find this page helpful?
Section:
Device settings
SUBMIT
General usage
Props
DeviceSettings
DeviceSelectorVideo
DeviceSelectorAudioInput
DeviceSelectorAudioOutput
Customization

Avatar

The Avatar element is generally used to show the image and/or name of participants of a video call. If no image is provided/an error occurs loading the image, it will display a fallback image.

Of course, it can also be used in any other circumstances that you like, for example, in user lists, profiles, and much more.

Feedback
General usage
â€‹

The way you can use the Avatar element in a react component is like this:

import { Avatar } from '@stream-io/video-react-sdk';

export const MyAvatarExample = () => {
  return (

    <Avatar imageSrc="https://getstream.io/random_png/?id=stefan&name=stefan" />

  );
};

Feedback
Props
â€‹
imageSrc
â€‹
Type
string | undefined

The URL of the user's profile image.

name
â€‹
Type
string | undefined

The name of the user.

styles
â€‹
Type
CSSProperties & Record<string, string \| number>

Custom CSS to attach to the avatar image/fallback.

Feedback
Customization
â€‹

If you want to build your own avatar component, you'll have to provide your own ParticipantViewUI component. For more information, visit the ParticipantView customizations guide.

Feedback
Previous
Video preview
Next
Call statistics
Did you find this page helpful?
Section:
Avatar
SUBMIT
General usage
Props
imageSrc
name
styles
Customization

Participants list

The SDK provides a default implementation for listing call participants in CallParticipantsList component.

Default UI of call participant list
Default UI of call participant list with admin actions menu
Default UI of call participant list with user actions menu

The component supports the following features:

list active with their device mute statuses
list blocked participants
searching among the active or blocked participants
mute all users by call owners
per user actions like pin, block etc. (depends on each participant's permissions)
Feedback
General usage
â€‹
import {
  Call,
  CallParticipantsList,
  StreamCall,
} from '@stream-io/video-react-sdk';

const MyParticipantList = () => {
  let call: Call;

  return (
    <StreamCall call={call}>
      <CallParticipantsList />
    </StreamCall>
  );
};

Feedback
Props
â€‹
activeUsersSearchFn
â€‹
Type
(searchQuery: string) => Promise<StreamVideoParticipant[]> | undefined

Custom function to override the searching logic of active participants.

blockedUsersSearchFn
â€‹
Type
(searchQuery: string) => Promise<string[]> | undefined

Custom function to override the searching logic of blocked users.

debounceSearchInterval
â€‹
Type	Default
number | undefined	200

Interval in ms, during which the participant search calls will be debounced.

onClose
â€‹
Type
() => void

Click event listener function to be invoked in order to dismiss/hide the CallParticipantsList from the UI.

Feedback
Customization
â€‹

You can create your own participant list using the SDK's participant hooks.

Feedback
Previous
Ringing call
Next
Device settings
Did you find this page helpful?
Section:
Participants list
SUBMIT
General usage
Props
activeUsersSearchFn
blockedUsersSearchFn
debounceSearchInterval
onClose
Customization

StreamVideo

The <StreamVideo /> provider makes the client and its state available to all child components and initializes internationalization

Feedback
General usage
â€‹
import { StreamVideo, StreamVideoClient } from '@stream-io/video-react-sdk';

export const App = () => {
  const client = new StreamVideoClient(/* ... */);

  return (

    <StreamVideo client={client}>

      <MyUI />
    </StreamVideo>
  );
};

Feedback
Props
â€‹
client
â€‹
Type
StreamVideoClient

StreamVideoClient instance propagated to the component's children as a part of StreamVideoContext. Children can access it with useStreamVideoClient() hook.

i18nInstance
â€‹
Type
StreamI18n | undefined

The StreamI18n instance to use, if undefined is provided, a new instance will be created. For more information, see our Internationalization guide.

language
â€‹
Type	Default
string | undefined	en

The language to translate UI labels. For more information, see our Internationalization guide.

translationsOverrides
â€‹
Type
TranslationsMap | undefined

Custom translations that will be merged with the defaults provided by the library. For more information, see our Internationalization guide.

Feedback
Previous
StreamCall
Next
Call Control Actions
Did you find this page helpful?
Section:
StreamVideo
SUBMIT
General usage
Props
client
i18nInstance
language
translationsOverrides

Call recordings list

The CallRecordingList component is designed to display the list of recordings. CallRecordingList is a composite component rendering:

CallRecordingListHeader
CallRecordingListItem
EmptyCallRecordingList
LoadingCallRecordingList
Empty call recording list
Loading call recording list
Feedback
General usage
â€‹
import { CallRecording, CallRecordingList } from '@stream-io/video-react-sdk';

const MyCallRecordings = () => {
  let callRecordings: CallRecording[];

  return <CallRecordingList callRecordings={callRecordings} />;
};

NOTE

The CallRecordingList component just displays the data. It does not retrieve the call recordings data. See the call recording guide to learn more about retrieving the call recording data.

Feedback
Call recording list components
â€‹

The components rendered by CallRecordingList can be overridden through CallRecordingListProps. The default components descriptions follow.

CallRecordingListHeader
â€‹

Component rendering title and call recordings count as well as a button to query the latest state of call recordings.

Props
â€‹
Name	Description	Type
callRecordings	Array of CallRecording objects	CallRecording[]
onRefresh	Callback to invoke once the "refresh" button is clicked. Usually, you'll reload the data.	() => void
CallRecordingListItem
â€‹

Component displays download link, copy-to-clipboard link button and recording date as a recording identifier.

Props
â€‹
Name	Description	Type
callRecording	CallRecording object to represent	CallRecording
EmptyCallRecordingList
â€‹

Component displayed instead of CallRecordingListItem list if there are no recordings associated with the given call.

Props
â€‹

None

LoadingCallRecordingList
â€‹

Component displayed while the latest call recordings data is queried. The default implementation renders the current call recording list and a loading indicator at the bottom.

Props
â€‹
Name	Description	Type
callRecordings	Array of currently loaded CallRecording objects	CallRecording[]
Feedback
Props
â€‹
callRecordings
â€‹
Type
CallRecording[]

Array of CallRecording objects to be displayed.

CallRecordingListHeader
â€‹
Type
ComponentType<CallRecordingListHeaderProps> | undefined

Custom component to replace the default header implementation.

CallRecordingListItem
â€‹
Type
ComponentType<CallRecordingListItemProps> | undefined

Custom component to replace the default list item implementation.

EmptyCallRecordingList
â€‹
Type
ComponentType | undefined

Custom component to replace the default empty list component implementation.

loading
â€‹
Type
boolean | undefined

Signals that a request for new list of CallRecording object has been initiated.

LoadingCallRecordingList
â€‹
Type
ComponentType<LoadingCallRecordingListProps> | undefined

Custom component to be rendered when loading is true.

Feedback
Customization
â€‹

The CallRecordingList component accepts UI components as props to override parts of the displayed UI. It's also possible to build your own call recordings UI from scratch.

onRefresh
â€‹
Type
() => void

An callback to invoke once the "refresh" button is clicked. Usually, you'll reload the data.

Feedback
Previous
Call Control Actions
Next
Ringing call
Did you find this page helpful?
Section:
Call recordings list
SUBMIT
General usage
Call recording list components
CallRecordingListHeader
CallRecordingListItem
EmptyCallRecordingList
LoadingCallRecordingList
Props
callRecordings
CallRecordingListHeader
CallRecordingListItem
EmptyCallRecordingList
loading
LoadingCallRecordingList
Customization
onRefresh

Permission requests

The default component to display a list of permission requests from other call participants is called PermissionRequests. The component takes care of:

listing the permission requests if the user has permissions to grant permissions
displaying the buttons to grant or ignore the permission requests
Default UI of permission request notification
Default UI of permission requests listing
Feedback
General usage
â€‹

The default component is just rendered without passing any props:

import { PermissionRequests } from '@stream-io/video-react-sdk';

const MyComponent = () => {
  // omitted code ...

  return (
    /* omitted code ... */
    <PermissionRequests />
    /* omitted code ... */
  );
};

Feedback
Customization
â€‹

The component is not customizable through props, only by applying CSS to elements it renders.

NOTE

To learn more about creating custom permission requests listings, have a look at our permission requests customization guide.

Feedback
Previous
Permission notification
Next
Reaction
Did you find this page helpful?
Section:
Permission requests
SUBMIT
General usage
Customization

Ringing call

The component RingingCall is designed to represent incoming or outgoing ring call. The default implementation displays:

call member avatars
call connection status
call control buttons to accept or cancel the call
Default incoming call panel
Default outgoing call panel
Feedback
General usage
â€‹
import { Call, RingingCall, StreamCall } from '@stream-io/video-react-sdk';

const MyRingingCallUI = () => {
  let call: Call;

  return (
    <StreamCall call={call}>
      <RingingCall />
    </StreamCall>
  );
};

Feedback
Ringing call controls
â€‹

The RingingCall component features CancelCallButton to reject/cancel the outgoing/incoming call and in case of incoming call panel, also AcceptCallButton is displayed.

Feedback
Props RingingCall
â€‹
includeSelf
â€‹
Type	Default
boolean | undefined	false

Whether to include the current user in the list of members to show.

totalMembersToShow
â€‹
Type	Default
number | undefined	3

The maximum number of members to show.

Feedback
Props RingingCallControls
â€‹

None

Feedback
Customization
â€‹

If you want to create your own ringing call panel, have a look at our ringing call panel customization guide.

Feedback
Previous
Call recordings list
Next
Participants list
Did you find this page helpful?
Section:
Ringing call
SUBMIT
General usage
Ringing call controls
Props RingingCall
includeSelf
totalMembersToShow
Props RingingCallControls
Customization

Speaking while muted notification

The SpeakingWhileMuted component is based on Notification component that is a simple popover. The SDK attaches the component to ToggleAudioPublishingButton. The popover rendering is controlled by sound detection mechanism put in place by createSoundDetector() function.

Feedback
General usage
â€‹

The component is used by wrapping the component to which it will refer:

<SpeakingWhileMutedNotification>
  <ToggleAudioPublishingButton />
</SpeakingWhileMutedNotification>

Feedback
Props
â€‹
text
â€‹
Type	Default
string | undefined	'You are muted. Unmute to speak.'

Text message displayed by the notification.

Feedback
Customization
â€‹

To learn more about creating sound detection functionality, have a look at our speaking-while-muted tutorial.

Feedback
Previous
Recording in progress notification
Next
Overview
Did you find this page helpful?
Section:
Speaking while muted notification
SUBMIT
General usage
Props
text
Customization

Reaction

Reaction component is used to display emojis in real-time for a specified amount of time. You can utilise this functionality, for example, to notify other participants that you want to speak by "raising hand". Our default sorting algorithm will push participants with raised hand to the top of the list for better visibility. Learn more about reaction events and their customization in the Reactions & Custom Events guide and see how sorting works in the Participant Sorting guide.

Feedback
General usage
â€‹

Our DefaultParticipantViewUI already comes with the Reaction component built-in but if you're building your custom ParticipantViewUI here's how you'd incorporate the Reaction component into your UI:

import {
  Reaction,
  useParticipantViewContext,
  defaultEmojiReactionMap,
} from '@stream-io/video-react-sdk';

const customEmojiReactionMap = {
  ...defaultEmojiReactionMap,
  ':lol:': 'ðŸ˜‚',
};

export const CustomParticipantViewUI = () => {
  const { participant } = useParticipantViewContext();
  return (
    <>
      <Reaction
        participant={participant}
        hideAfterTimeoutInMs={5000}
        emojiReactionMap={customEmojiReactionMap}
      />
      {/* your other custom UI elements */}
    </>
  );
};


Now we can pass this custom ParticipantViewUI component down to our call layout components or directly to ParticipantView component in our custom call layout as described in the ParticipantView customizations guide.

Feedback
Props
â€‹
participant
â€‹
Type
StreamVideoParticipant

The participant whose reaction the component should display.

hideAfterTimeoutInMs
â€‹
Type
number | undefined

Timeout in miliseconds after which the component resets participant reaction state.

empjiReactionMap
â€‹
Type
Record<string, string>

Mapping of the emoji keys (for example :like:) and the associated emoji (for example ðŸ‘)

The SDK comes with the following default mapping:

:like: (renders ðŸ‘)
:raise-hand: (renders âœ‹)
:fireworks:: (renders ðŸŽ‰)
Feedback
Customization
â€‹

If you want to build your own reaction component, you'll have to provide your own ParticipantViewUI component. For more information visit the ParticipantView customizations guide.

Feedback
Previous
Permission requests
Next
Recording in progress notification
Did you find this page helpful?
Section:
Reaction
SUBMIT
General usage
Props
participant
hideAfterTimeoutInMs
empjiReactionMap
Customization

Call Control Actions

Call control actions allow users to execute actions during a call (for example, start recording), and/or before joining (for example, mute/unmute microphone). The built-in CallControls component displays all relevant call controls during a call. Each call control is available to use as separate component.

Feedback
General usage
â€‹

The CallControls component displays the available call controls (based on user permissions).

import '@stream-io/video-react-sdk/dist/css/styles.css';
import {
  Call,
  CallControls,
  StreamCall,
  SpeakerLayout,
} from '@stream-io/video-react-sdk';

const MyCallUI = () => {
  let call: Call;

  return (
    <StreamCall call={call}>
      <SpeakerLayout />

      <CallControls />

    </StreamCall>
  );
};

Feedback
Props
â€‹
onLeave
â€‹
Type
() => void | undefined

A callback to be called after the call is left using the hangup button.

Feedback
Built-in call controls
â€‹

Each call control is available as a separate UI component. Each component takes care of authorization.

AcceptCallButton
â€‹

This component is used in the ringing call component to accept an incoming call.

Props
â€‹
Name	Description	Type
disabled	Set true to disable the button	boolean | undefined
onClick	Event handler to override the default click behavior	MouseEventHandler<HTMLButtonElement> | undefined
onAccept	Custom event handler to call after the call was joined	() => void | undefined
CancelCallButton
â€‹

This component can be used to leave a call or to reject an incoming/outgoing call.

Props
â€‹
Name	Description	Type
disabled	Set true to disable the button	boolean | undefined
onClick	Event handler to override the default click behavior	MouseEventHandler<HTMLButtonElement> | undefined
onLeave	Custom event handler to call after the call was left	() => void | undefined
CancelCallConfirmButton
â€‹

This component can be used to leave a call or end the call for all participants but only if the particpant has the requiredGrants OwnCapability.END_CALL.

Props
â€‹
Name	Description	Type
disabled	Set true to disable the button	boolean | undefined
onClick	Event handler to override the default click behavior	MouseEventHandler<HTMLButtonElement> | undefined
onLeave	Custom event handler to call after the call was left	() => void | undefined
ReactionsButton
â€‹

This component can be used to send reactions during a call. The following reactions are supported by default:

like ðŸ‘
raise hand âœ‹
fireworks ðŸŽ‰
Props
â€‹
Name	Description	Type
reactions	Override or extend the default reactions/emojis	StreamReaction[] | undefined
RecordCallButton
â€‹

This component can be used to start/stop call recording. It's also used as a visual indicator to let participants know if there is an ongoing call recording.

Props
â€‹
Name	Description	Type
caption	The explanatory text displayed under the control button	string | undefined
RecordCallConfirmationButton
â€‹

This component can be used to start/stop a call recording. A confirmation will be show to let the particpant cancel or confirm to ending the recording that is in progress.

Props
â€‹
Name	Description	Type
caption	The explanatory text displayed under the control button	string | undefined
ScreenShareButton
â€‹

This component can be used to start/stop screen sharing. It's also used as a visual indicator to let participants know if there is an ongoing screen share. This component only allows a single ongoing screen share.

Props
â€‹
Name	Description	Type
caption	The explanatory text displayed under the control button	string | undefined
ToggleAudioPreviewButton
â€‹

This component can be used to toggle the initial audio state in the lobby preview.

Props
â€‹
Name	Description	Type
caption	The explanatory text displayed under the control button	string | undefined
ToggleAudioPublishingButton
â€‹

This component can be used to

mute/unmute the microphone during a call
select an audio input device during a call
Props
â€‹
Name	Description	Type
caption	The explanatory text displayed under the control button	string | undefined
ToggleAudioOutputButton
â€‹

This component can be used to select the audio output device (if the currently used browser supports audio output selection).

Props
â€‹
Name	Description	Type
caption	The explanatory text displayed under the control button	string | undefined
ToggleVideoPreviewButton
â€‹

This component can be used to toggle the initial video state in the lobby preview.

Props
â€‹
Name	Description	Type
caption	The explanatory text displayed under the control button	string | undefined
ToggleVideoPublishingButton
â€‹

This component can be used to

mute/unmute the camera during a call
select a video input device during a call
Props
â€‹
Name	Description	Type
caption	The explanatory text displayed under the control button	string | undefined
CallStatsButton
â€‹

The component can be used to show/hide the call statistics.

Props
â€‹

None

Feedback
Customization
â€‹

You can create your own custom component using the built-in call controls as building blocks.

If you want to create custom call controls, follow the Call Controls UI Cookbook guide for more information.

Feedback
Previous
StreamVideo
Next
Call recordings list
Did you find this page helpful?
Section:
Call Control Actions
SUBMIT
General usage
Props
onLeave
Built-in call controls
AcceptCallButton
CancelCallButton
CancelCallConfirmButton
ReactionsButton
RecordCallButton
RecordCallConfirmationButton
ScreenShareButton
ToggleAudioPreviewButton
ToggleAudioPublishingButton
ToggleAudioOutputButton
ToggleVideoPreviewButton
ToggleVideoPublishingButton
CallStatsButton
Customization

ParticipantView

The ParticipantView component is a core component that renders a participant's video and plays the participant's audio.

It can toggle between video and avatar based on the participant's video state. It displays information about the participant, their device settings and connection quality. It also provides action buttons (for example, to pin the participant).

The ParticipantView component is used to build up the different call layouts.

To optimize performance,

the component won't stream video for participants that are not visible in the viewport
for visible participants it will request the appropriate video track quality and resolution (dynascale)

NOTE

Please note that we suggest not to create a custom ParticipantView component as it contains complex, low-level logic related to performance. Please refer to the Customization section to see how you can tailor the component to your needs.

Feedback
General usage
â€‹

You can use the ParticipantView component to create your own call layout:

import { ParticipantView, useCallStateHooks } from '@stream-io/video-react-sdk';

const MyCallUI = () => {
  const { useParticipants } = useCallStateHooks();
  const participants = useParticipants();
  return (
    <>
      {participants.map((p) => (

        <ParticipantView participant={p} key={p.sessionId} />

      ))}
    </>
  );
};

Feedback
Props
â€‹
participant
â€‹
Type
StreamVideoParticipant

The participant whose video/audio stream we want to play.

ParticipantViewUI
â€‹
Type
ComponentType | ReactElement | null

Override the default UI for rendering participant information/actions.

VideoPlaceholder
â€‹
Type
ComponentType | ReactElement | null

Override the default UI that's visible when a participant turned off their video.

trackType
â€‹
Type
videoTrack | screenShareTrack | none

The kind of video stream to play for the given participant. The default value is video. You can use none if you're building an audio-only call.

className
â€‹
Type
string | undefined

Custom class applied to the root DOM element.

refs
â€‹
Type
{setVideoElement: Function, setVideoPlaceholderElement: Function} | undefined

An object with set functions meant for exposing the video and video placeholder elements to the integrators.

muteAudio
â€‹
Type
boolean

This prop is only useful for advanced use-cases (for example building your own paginated layout). When set to true it will mute the given participant's audio stream on the client side. The local participant is always muted.

Feedback
Customization
â€‹

The ParticipantView customizations guide tells all the important information about the customization options. It's useful when you want to attach custom event handlers to these elements.

We also have additional guides focusing on specific parts:

Video placeholder
Connection Quality Indicator
Connection Unstable Indicator
Custom Label
Feedback
Previous
Call layout
Next
StreamCall
Did you find this page helpful?
Section:
ParticipantView
SUBMIT
General usage
Props
participant
ParticipantViewUI
VideoPlaceholder
trackType
className
refs
muteAudio
Customization

Video preview

The aim of the VideoPreview component is to offer a glimpse into how we appear to others before joining a call. This component is suitable for call lobby scenario. The component allows for UI customisation and at the same time handles the starting, playing and error handling logic for us.

You can customize what is displayed, when:

the video is starting to play
the video is disabled
camera device could not be found

The custom components should be passed to VideoPreview props. See the Props section for more details.

Feedback
General usage
â€‹
import { Call, VideoPreview, StreamCall } from '@stream-io/video-react-sdk';

const MyVideoPreview = () => {
  let call: Call;

  return (
    <StreamCall call={call}>
      <VideoPreview />
    </StreamCall>
  );
};

Feedback
Props
â€‹
className
â€‹
Type	Default
string | undefined	undefined

Additional CSS class to add to the component container.

mirror
â€‹
Type	Default
boolean | undefined	true

Enforces mirroring of the video on the X axis.

DisabledVideoPreview
â€‹
Type
ComponentType | undefined

Component rendered when user turns off the video.

NoCameraPreview
â€‹
Type
ComponentType | undefined

Component rendered when no camera devices are available.

StartingCameraPreview
â€‹
Type
ComponentType | undefined

Component rendered above the BaseVideo until the video is ready (meaning until the play event is emitted).

Feedback
Customization
â€‹

If the built-in props don't provide enough flexibility for you, you can create your own video preview component. You can rely on the state and API provided by the Camera API.

Feedback
Previous
Device settings
Next
Avatar
Did you find this page helpful?
Section:
Video preview
SUBMIT
General usage
Props
className
mirror
DisabledVideoPreview
NoCameraPreview
StartingCameraPreview
Customization

StreamCall

The <StreamCall /> component is a declarative component wrapper around Call objects. It utilizes the StreamCallProvider to make the call and its state available to all child components.

Feedback
General usage
â€‹
import { StreamCall } from '@stream-io/video-react-sdk';

export const App = () => {
  const call = /* ... */;

  return (

    <StreamCall call={call}>

      <MyUI />
    </StreamCall>
  );
};

Feedback
Props
â€‹
call
â€‹
Type
Call

Stream's Call instance propagated to the component's children as a part of StreamCallContext. Children can access it with useCall() hook.

Feedback
Previous
ParticipantView
Next
StreamVideo
Did you find this page helpful?
Section:
StreamCall
SUBMIT
General usage
Props
call

Call layout

The SDK comes with two built-in call layouts.

The PaginatedGridLayout displays participants in a grid that is paginated.

The SpeakerLayout displays participants in a configuration where the dominant speaker/shared screen is in focus and other participants are displayed in a smaller bar.

The LivestreamLayout is suitable for livestreaming and displays the dominant speaker/shared screen in a large video.

Feedback
General usage
â€‹

Both layouts gather all necessary state information via hooks, so you don't need to provide state-related props:

import '@stream-io/video-react-sdk/dist/css/styles.css';
import {
  CallControls,
  StreamCall,
  StreamTheme,
  StreamVideo,
  SpeakerLayout,
} from '@stream-io/video-react-sdk';

const MyApp = () => {
  return (
    <StreamVideo client={client}>
      <StreamTheme>
        <StreamCall call={call}>

          <SpeakerLayout />

          <CallControls />
        </StreamCall>
      </StreamTheme>
    </StreamVideo>
  );
};

import '@stream-io/video-react-sdk/dist/css/styles.css';
import {
  CallControls,
  StreamCall,
  StreamTheme,
  StreamVideo,
  PaginatedGridLayout,
} from '@stream-io/video-react-sdk';

const MyApp = () => {
  return (
    <StreamVideo client={client}>
      <StreamTheme>
        <StreamCall call={call}>

          <PaginatedGridLayout />

          <CallControls />
        </StreamCall>
      </StreamTheme>
    </StreamVideo>
  );
};

Feedback
Built-in Layouts
â€‹
PaginatedGridLayout
â€‹
Props
â€‹
Name	Description	Type
groupSize	The number of participants to display per page	number | undefined
excludeLocalParticipant	Whether to exclude the local participant from the grid	boolean | undefined
pageArrowsVisible	Turns on/off the pagination arrows	boolean | undefined
ParticipantViewUI	See ParticipantView documentation	See ParticipantView documentation
VideoPlaceholder	See ParticipantView documentation	See ParticipantView documentation
SpeakerLayout
â€‹
Props
â€‹
Name	Description	Type
participantsBarPosition	The position of the participants who are not in focus, the default is bottom. Providing null will hide the bar	top | bottom | left | right | null
ParticipantViewUISpotlight	The participant UI for the spotlight view, see ParticipantView documentation	See ParticipantView documentation
ParticipantViewUIBar	The participant UI for the participants in the bar, see ParticipantView documentation	See ParticipantView documentation
VideoPlaceholder	See ParticipantView documentation	See ParticipantView documentation
LivestreamLayout
â€‹
Props
â€‹
Name	Description	Type
muted	Mutes all audio	boolean
enableFullscreen	Will render a button to enable fullscreen mode	boolean
showParticipantCount	Will show the number of participants	boolean
showDuration	Will show the duration of the livestream	boolean
showLiveBadge	Will show a badge whether the livestream is live or not	boolean
showSpeakerName	Will show the name of the speaker	boolean
floatingParticipantProps	Props to pass to the floating participant view	object
floatingParticipantProps.position	Position of the floating participant view	string
Feedback
Customization
â€‹

If the built-in layouts aren't what you're looking for, it's also possible to create your own layout, see our Custom Call Layout guide for more information.

Feedback
Previous
Theme
Next
ParticipantView
Did you find this page helpful?
Section:
Call layout
SUBMIT
General usage
Built-in Layouts
PaginatedGridLayout
SpeakerLayout
LivestreamLayout
Customization

Picture-in-Picture

In this guide, you'll learn how to display floating video element of the ParticipantView component which is visible even if you minimise your browser window utilising the Picture-in-Picture API. You might want to use this customization in combination with SpeakerLayout (ParticipantViewUISpotlight property) where spotlighted ParticipantView switches between dominant speakers automatically.

Feedback
Define custom ParticipantViewUI
â€‹

The ParticipantViewUI template is incredibly versatile and can render anything you want it to. In this case, we'll be rendering a single button which we'll use to open the video element in the floating picture-in-picture window.

import { useEffect } from 'react';
import { useParticipantViewContext } from '@stream-io/video-react-sdk';

const CustomParticipantViewUI = () => {
  const { videoElement } = useParticipantViewContext();
  const [pictureInPictureElement, setPictureInPictureElement] = useState(
    document.pictureInPictureElement,
  );

  useEffect(() => {
    if (!videoElement) return;

    // sync local state
    const handlePictureInPicture = () => {
      setPictureInPictureElement(document.pictureInPictureElement);
    };

    videoElement.addEventListener(
      'enterpictureinpicture',
      handlePictureInPicture,
    );
    videoElement.addEventListener(
      'leavepictureinpicture',
      handlePictureInPicture,
    );

    return () => {
      videoElement.removeEventListener(
        'enterpictureinpicture',
        handlePictureInPicture,
      );
      videoElement.removeEventListener(
        'leavepictureinpicture',
        handlePictureInPicture,
      );
    };
  }, [videoElement]);

  const togglePictureInPicture = () => {
    if (videoElement && pictureInPictureElement !== videoElement)
      return videoElement.requestPictureInPicture().catch(console.error);

    document.exitPictureInPicture().catch(console.error);
  };

  return (
    <>
      <button
        disabled={!document.pictureInPictureEnabled}
        style={{ position: 'absolute', top: 10, right: 10 }}
        onClick={togglePictureInPicture}
      >
        {pictureInPictureElement === videoElement ? 'Leave' : 'Enter'}{' '}
        picture-in-picture
      </button>
      {/* your other custom UI elements */}
    </>
  );
};

Feedback
Final steps
â€‹

Now we can pass this custom ParticipantViewUI component down to our call layout components or directly to ParticipantView component in our custom call layout as described in the ParticipantView customizations guide.

Feedback
Previous
Keyboard shortcuts
Did you find this page helpful?
Section:
Picture-in-Picture
SUBMIT
Define custom ParticipantViewUI
Final steps

Keyboard shortcuts

In this guide, you'll learn how to apply keyboard shortcuts to your Stream Video application. Some users find it much easier to use their keyboard instead of reaching for their mouse/touchpad and having to find an unmute button to be then able click to unmute. In this example we'll be implementing Ctrl + d (or âŒ˜ + d on Mac) and Ctrl + e (or âŒ˜ + e on Mac) shortcuts to mute/unmute your video and audio.

Feedback
Define custom
useKeyboardShortcuts
hook
â€‹

As this hook will introduce keyboard shortcuts related to CallControls (mute/unmute audio) we should ideally invoke it in the same component to group logical parts together for easier debugging later. The same goes for your other keyboard shortcuts you might introduce to your application. Learn how to adjust your CallControls component in the Replacing Call Controls guide.

import { useEffect } from 'react';
import { useCallStateHooks } from '@stream-io/video-react-sdk';

const isMacOS = () => !!navigator.userAgent.match(/(Mac\s?OS)/g)?.length;

export const useKeyboardShortcuts = () => {
  const { useCameraState, useMicrophoneState } = useCallStateHooks();
  const { microphone } = useMicrophoneState();
  const { camera } = useCameraState();

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (
        e.key !== 'd' ||
        (!e.metaKey && isMacOS()) ||
        (!e.ctrlKey && !isMacOS())
      )
        return;
      e.preventDefault();

      microphone.toggle().catch(console.error);
    };

    window.addEventListener('keydown', handleKeyDown);

    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [microphone]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (
        e.key !== 'e' ||
        (!e.metaKey && isMacOS()) ||
        (!e.ctrlKey && !isMacOS())
      )
        return;
      e.preventDefault();

      camera.toggle().catch(console.error);
    };

    window.addEventListener('keydown', handleKeyDown);

    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [camera]);
};

Refactor with the use of
hotkeys-js
â€‹

The previous implementation looks a bit messy and hard to read so we'll refactor this hook with the help of the hotkeys-js which makes shortcut registering and handling much easier.

import { useEffect } from 'react';
import hotkeys from 'hotkeys-js';
import { useCallStateHooks } from '@stream-io/video-react-sdk';

const isMacOS = () => !!navigator.userAgent.match(/(Mac\s?OS)/g)?.length;

export const useKeyboardShortcuts = () => {
  const { useCameraState, useMicrophoneState } = useCallStateHooks();
  const { microphone } = useMicrophoneState();
  const { camera } = useCameraState();

  useEffect(() => {
    const shortcuts = 'cmd+d,ctrl+d';
    hotkeys(shortcuts, (e, ke) => {
      if (isMacOS() && ke.shortcut !== 'cmd+d') return;
      e.preventDefault();

      microphone.toggle().catch(console.error);
    });

    return () => hotkeys.unbind(shortcuts);
  }, [microphone]);

  useEffect(() => {
    const shortcuts = 'cmd+e,ctrl+e';
    hotkeys(shortcuts, (e, ke) => {
      if (isMacOS() && ke.shortcut !== 'cmd+e') return;
      e.preventDefault();

      camera.toggle().catch(console.error);
    });

    return () => hotkeys.unbind(shortcuts);
  }, [camera]);
};

Feedback
Previous
ParticipantView fullscreen mode
Next
Picture-in-Picture
Did you find this page helpful?
Section:
Keyboard shortcuts
SUBMIT
Define custom useKeyboardShortcuts hook
Refactor with the use of hotkeys-js

ParticipantView fullscreen mode

In this guide, you'll learn how to display ParticipantView in a fullscreen mode. To make this work we'll be utilising element.requestFullscreen browser API and ParticipantViewContext to reach for participantViewElement. You might want to use this customization in combination with SpeakerLayout (ParticipantViewUISpotlight property) where spotlighted ParticipantView switches between dominant speakers automatically.

Feedback
Define custom ParticipantViewUI
â€‹

The ParticipantViewUI template is incredibly versatile and can render anything you want it to. In this case, we'll be rendering a single button which we'll use to toggle between fullscreen and normal mode.

import { useParticipantViewContext } from '@stream-io/video-react-sdk';

const CustomParticipantViewUI = () => {
  const { participantViewElement } = useParticipantViewContext();
  const [isFullsreenElement, setIsFullscreenElement] = useState(false);

  useEffect(() => {
    // sync local state
    const handleFullscreenChange = () => {
      setIsFullscreenElement(
        document.fullscreenElement === participantViewElement,
      );
    };

    window.addEventListener('fullscreenchange', handleFullscreenChange);

    return () =>
      window.removeEventListener('fullscreenchange', handleFullscreenChange);
  }, [participantViewElement]);

  const toggleFullscreen = () => {
    if (isFullsreenElement) {
      return document.exitFullscreen();
    }

    return participantViewElement?.requestFullscreen();
  };

  return (
    <>
      <button
        style={{ position: 'absolute', top: 10, right: 10 }}
        onClick={toggleFullscreen}
      >
        {isFullsreenElement ? 'Leave' : 'Enter'} fullscreen
      </button>
      {/* your other custom UI elements */}
    </>
  );
};

Feedback
Final steps
â€‹

Now we can pass this custom ParticipantViewUI component down to our call layout components or directly to ParticipantView component in our custom call layout as described in the ParticipantView customizations guide.

Feedback
Previous
Broadcasting
Next
Keyboard shortcuts
Did you find this page helpful?
Section:
ParticipantView fullscreen mode
SUBMIT
Define custom ParticipantViewUI
Final steps

Recording

One highly sought-after feature in many communication applications is call recording. Whether it's for legal compliance, quality assurance, or simply for future reference, the ability to record calls is essential in numerous scenarios.

This documentation article serves as a guide for implementing a call recording feature in your application. We will explore the technical aspects and best practices involved in capturing and storing recording data during calls.

Feedback
Recording calls
â€‹

The Call object exposes the call recording API. To start recording, we simply invoke call.startRecording(). To stop recording, we use call.stopRecording(). To determine, whether a call recording is in progress, we use useIsCallRecordingInProgress hook. This may serve us well when we want to provide visual clues about the recording state. We have to be aware, that it can take a few moments until a call recording starts. We recommend creating a state for signaling that the call recording is starting, but has not begun yet.

import { useCallback, useEffect, useState } from 'react';
import { useCall, useCallStateHooks } from '@stream-io/video-react-sdk';

import { LoadingIndicator } from '../LoadingIndicator';

export const CustomCallRecordButton = () => {
  const call = useCall();
  const { useIsCallRecordingInProgress } = useCallStateHooks();
  const isCallRecordingInProgress = useIsCallRecordingInProgress();
  const [isAwaitingResponse, setIsAwaitingResponse] = useState(false);

  useEffect(() => {
    if (!call) return;
    // we wait until call.recording_started/stopped event
    // to remove the loading indicator
    const eventHandlers = [
      call.on('call.recording_started', () => setIsAwaitingResponse(false)),
      call.on('call.recording_stopped', () => setIsAwaitingResponse(false)),
    ];
    return () => {
      eventHandlers.forEach((unsubscribe) => unsubscribe());
    };
  }, [call]);

  const toggleRecording = useCallback(async () => {
    try {
      setIsAwaitingResponse(true);
      if (isCallRecordingInProgress) {
        await call?.stopRecording();
      } else {
        await call?.startRecording();
      }
    } catch (e) {
      console.error(`Failed start recording`, e);
    }
  }, [call, isCallRecordingInProgress]);

  return isAwaitingResponse ? (
    <LoadingIndicator />
  ) : (
    <button onClick={toggleRecording}>{/* Button content */}</button>
  );
};

Permissions
â€‹

To start and stop recording, the user has to have corresponding permissions. We therefore encourage the integrators to check the permissions before allowing users to execute a given action. The SDK bundles component Restricted that renders its children only if the user has sufficient permissions. The SDK's RecordCallButton makes use of the Restricted component.

To learn more about permissions, take a look at our permissions guide.

Call recording SDK components
â€‹

The React SDK comes with RecordCallButton, that takes care of initiating the call recording.

Feedback
Acquiring call recordings data
â€‹

The call recording data can be retrieved by calling the Call method queryRecordings(). By default, it retrieves all the call recordings for a given call (call CID). However, it accepts a single argument callSessionId that allows us to retrieve only recordings done during a single call session. The method returns ListRecordingsResponse that carries an array of CallRecording objects accessible through recordings key.

NOTE

Multiple calls can be recorded during a single call session, but a single call CID can be reused for multiple sessions, too.

NOTE

The call recording is not immediately available when the call.recording_stopped event is delivered. It may take 30 or more seconds for a recording to be available, advertised by emitting call.recording_ready event.

Feedback
Call recording listing SDK components
â€‹

The React SDK provides CallRecordingList component to display call recordings.

Feedback
Previous
GDPR Endpoints
Next
Broadcasting
Did you find this page helpful?
Section:
Recording
SUBMIT
Recording calls
Permissions
Call recording SDK components
Acquiring call recordings data
Call recording listing SDK components

Broadcasting

Broadcasting serves as a means of transmitting live or pre-recorded content to a wide audience.

We can choose from two approaches to broadcasting the media:

HLS - slight delay, better buffering
WebRTC - lower latency, less reliability

It is up to the integrators to decide, what approach will be used in their apps for the audience to consume the streams.

NOTE

We have built a livestream app tutorial that relies on the broadcasting feature. The demo expands on how to implement both, the HLS and the WebRTC approach to streaming.

Feedback
Call type for broadcasting
â€‹

Stream infrastructure recognizes few pre-built call types. Among them, the type livestream type is the best suited for broadcasting events. When a livestream call is created, it is set to backstage mode by default. The backstage mode makes it easy to build a flow where hosts can set up cameras and equipment before going live.

Feedback
Starting and stopping the broadcasting
â€‹

We have the following Call methods at our disposal to start and stop the broadcasting:

await call.startHLS();
await call.stopHLS();


alternatively:

await call.goLive({ start_hls: true });


Once started broadcasting, the data source URL is available through playlist_url property accessible through the Call state:

import { useCallStateHooks } from '@stream-io/video-react-sdk';

// omitted code ...

const YourComponent = () => {
  const { useCallEgress } = useCallStateHooks();
  const egress = useCallEgress();
  const m3u8Playlist = egress?.hls.playlist_url;

  // omitted code ...
};


To play the video over HLS, a third-party library is required (for example HLS.js).

Feedback
Previous
Recording
Next
ParticipantView fullscreen mode
Did you find this page helpful?
Section:
Broadcasting
SUBMIT
Call type for broadcasting
Starting and stopping the broadcasting

GDPR Endpoints

GDPR documentation is coming soon...

Feedback
Previous
Events
Next
Recording
Did you find this page helpful?
Section:
GDPR Endpoints
SUBMIT

Chat Integration

In this tutorial we will guide you through the process of embedding video calling capabilities into a chat application. We will cover the following topics:

Boilerplate setup (clients instantiation, building blocks)
Initiating a ring call
Handling different call calling states (ringing, active call, call left etc.)
Handling different ring call events (call created, accepted, rejected and ended)
Handling multiple pending calls
Initiating group calls
Terminating a call (pending, active)
Feedback
Project setup and prerequisites
â€‹

Make sure you have the following prerequisites checked:

Registered Stream account
Have an app created in the Stream's dashboard to obtain app API key and secret.
Initiate the project (you can follow our introductory tutorial setup guide)
Have installed the Stream video and chat SDKs in the project:
npm install @stream-io/video-react-sdk stream-chat-react stream-chat

yarn add @stream-io/video-react-sdk stream-chat-react stream-chat

TIP

When implementing a ring call scenario as we do in this demo, it is important to have a good understanding of our ring call lifecycle. You can learn more about the topic in the Joinging & Creating Calls guide.

Feedback
App boilerplate
â€‹

We have prepared a demo application to accompany this guide. We do not aim to explain the whole demo application source code. The demo application will serve us to demonstrate the main concepts behind the video-in-chat integration.

NOTE

To initiate chat and video clients you are encouraged to use the same API key. The user tokens should be generated with the same secret. There is no need to create separate apps for chat and video.

Feedback
Initiating chat and video clients
â€‹
import type { UserResponse } from 'stream-chat';
import { Chat } from 'stream-chat-react';
import { StreamVideo, StreamVideoClient } from '@stream-io/video-react-sdk';
import { Channel } from './components/Channel';
import { Sidebar } from './components/Sidebar';
import { Video } from './components/Video';
import { useCreateChatClient } from './hooks';

import type { StreamChatType } from './types/chat';
import { useState } from 'react';

const Root = ({
  apiKey,
  user,
  userToken,
}: {
  apiKey: string;
  user: UserResponse<StreamChatType>;
  userToken: string;
}) => {
  const chatClient = useCreateChatClient<StreamChatType>({
    apiKey,
    tokenOrProvider: userToken,
    userData: user,
  });
  const [videoClient, setVideoClient] = useState<StreamVideoClient>();

  useEffect(() => {
    const _client = new StreamVideoClient({
      apiKey,
      user: userData,
      token: userToken,
    });
    setVideoClient(_client);

    return () => {
      _client.disconnectUser();
      setVideoClient(undefined);
    };
  }, []);

  if (!chatClient || !videoClient) return null;

  return (
    <Chat client={chatClient}>
      <StreamVideo client={videoClient}>
        <Sidebar user={user} />
        <Channel />
        <Video />
      </StreamVideo>
    </Chat>
  );
};

Feedback
Initiating a ring call
â€‹

In the ring call scenario we recommend to first create a call without immediately joining it. Use the Call method getOrCreate() to accomplish this. An example can be found in CreateCallButton component in the demo app:

import { useCallback } from 'react';
import {
  MemberRequest,
} from '@stream-io/video-react-sdk';
import { useChannelStateContext, useChatContext } from 'stream-chat-react';
import { LocalPhone } from '@mui/icons-material';
import { meetingId } from '../../utils/meetingId';
import type { StreamChatType } from '../../types/chat';

export const CreateCallButton = () => {
  const videoClient = /* ... */
  const { client } = useChatContext<StreamChatType>();
  const { channel } = useChannelStateContext<StreamChatType>();

  const createCall = useCallback(() => {
    videoClient?.call('default', meetingId()).getOrCreate({

      ring: true,

      data: {
        custom: {
          channelCid: channel.cid,
        },

        members: Object.values(channel.state.members).reduce<MemberRequest[]>(

          (acc, member) => {
            if (member.user_id !== client.user?.id) {
              acc.push({
                user_id: member.user_id!,
              });
            }
            return acc;
          },
          [],
        ),
      },
    });
  }, [videoClient, channel.cid, channel.state.members, client.user?.id]);

  const disableCreateCall = !videoClient;
  return (
    <button
      className="rmc__button rmc__button--green"
      disabled={disableCreateCall}
      onClick={createCall}
    >
      <LocalPhone />
    </button>
  );
};

NOTE

There is a flexibility in what channel members will be included in the call. And so the call can be a 1:1 or a group call. In our implementation we include all channel members.

Feedback
Handling the ring call states
â€‹

Once a ring call is initiated, call members start to receive ring call events (call.created, call.accepted, call.rejected, call.ended) over the WebSocket maintained by the video client. The video client updates the calls pool state and calling state of individual affected Call in response to these events.

Observing the calls pool state
â€‹

The array of all Call objects representing created pending (not accepted, rejected, neither ended) calls is continuously updated in response to each new call creation. You can use this array of Call objects to display incoming or outgoing calls in your application's UI. In our app the top-level Video component observes the changes using the useCalls hook and re-renders the UI to reflect the changes:

import { StreamCall, useCalls } from '@stream-io/video-react-sdk';

import { CallPanel } from './CallPanel';

export const Video = () => {

  const calls = useCalls();

  return (
    <>
      {calls.map((call) => (
        <StreamCall call={call} key={call.cid}>
          <CallPanel />
        </StreamCall>
      ))}
    </>
  );
};

NOTE

To identify an outgoing call, use the call.isCreatedByMe flag.

In our demo app, we reflect the incoming calls state in channel list. Channel preview shows buttons to accept or reject the incoming call. The outgoing call or incoming call in an active channel is represented by a CallPanel component floating above the chat UI:

Incoming calls in channel preview

This is done by embedding custom component ChannelPreviewCallControls in a ChannelPreview component:

import {
  AcceptCallButton,
  CallingState,
  CancelCallButton,
  useCall,
  useCallStateHooks,
} from '@stream-io/video-react-sdk';
import { useChatContext } from 'stream-chat-react';

export const ChannelPreviewCallControls = () => {
  const { channel: activeChannel } = useChatContext();

  // the Call instance is passed down from StreamCallProvider located in StreamCall

  const call = useCall();
  const { useCallCallingState } = useCallStateHooks();
  const callingState = useCallCallingState();

  const callingToActiveChannel =
    activeChannel && call && activeChannel.cid === call.state.custom.channelCid;

  const isRinging = callingState === CallingState.RINGING;

  if (call && isRinging && !callingToActiveChannel) {
    return (
      <div className="rmc__channel-preview__call-controls">
        <AcceptCallButton
          onClick={(e) => {
            e.stopPropagation();
            call.join();
          }}
        />
        <CancelCallButton
          onClick={(e) => {
            e.stopPropagation();
            call.leave({ reject: true });
          }}
        />
      </div>
    );
  }
  return null;
};

Observing the state of a specific call
â€‹

Each call can pass through different states. The call calling state is made available through useCallCallingState hook. Therefore, our custom CallPanel component displays different UI (pending call, active call) based on the information provided by the hook:

import {
  RingingCall,

  CallingState,

  CallParticipantsView,
  useCall,
  ScreenShareButton,
  SpeakingWhileMutedNotification,
  ToggleAudioPublishingButton,
  ToggleVideoPublishingButton,
  CancelCallButton,
  useCallStateHooks,
} from '@stream-io/video-react-sdk';
import { useChatContext } from 'stream-chat-react';
import { useState } from 'react';
import { useDraggable } from '../../hooks';

export const CallPanel = () => {
  const call = useCall();
  const { useCallCallingState, useCallCustomData } = useCallStateHooks();

  const callingState = useCallCallingState();

  const customData = useCallCustomData();

  const { channel: activeChannel } = useChatContext();
  const [panelElement, setPanelElement] = useState<HTMLDivElement | null>(null);
  useDraggable(panelElement);

  if (!call) return null;

  const callingToActiveChannel = activeChannel?.cid === customData.channelCid;


  if (CallingState.RINGING === callingState && !callingToActiveChannel)

    return null;


  if (callingState === CallingState.JOINED) {

    return (
      <div
        className="str-video__call-panel rmc__call-panel-wrapper"
        ref={setPanelElement}
      >
        <CallParticipantsView call={call} />
        <div className="rmc__active-call-controls">
          <ScreenShareButton />
          <SpeakingWhileMutedNotification>
            <ToggleAudioPublishingButton />
          </SpeakingWhileMutedNotification>
          <ToggleVideoPublishingButton />
          <CancelCallButton />
        </div>
      </div>
    );
  } else if (

    [CallingState.RINGING, CallingState.JOINING].includes(callingState)

  ) {
    return (
      <div className="rmc__call-panel-wrapper" ref={setPanelElement}>
        <RingingCall />
      </div>
    );
  }

  return null;
};

Feedback
Terminating a call
â€‹

What call termination means depends on the perspective:

A user can reject an incoming pending call.
A user can end / cancel own outgoing pending call.
A call participant (who joined a call) can leave a call.

In case of the group call scenario, a single user rejecting an incoming call or participant leaving a call does not terminate the call for anybody else. However, a user who initiated a pending call will end it for everybody if it has not been joined by others yet. Call is ended also, if the last member rejected the incoming call.

A user who rejected or left a call can re-join the same call again as long as the call has not been ended. The call cannot be re-joined only if ended.

So depending on the context, we associate a bit different click handlers with the button, that terminates the call for the current user:

Reject an incoming call Our RingingCallControls attaches the following callback to the CancelCallButton button that rejects the call:

<CancelCallButton
  onClick={() => {
    call.leave({ reject: true });
  }}
/>


End/Cancel an outgoing call & Leave already joined call The default callback of the CancelCallButton button is pure call.leave() without any parameters. Again the RingingCallControls as well as the demo's active call panel components make use of this by not overriding the default onClick:

<CancelCallButton />

Feedback
Adding default styles
â€‹

In order the default styles that come with both the chat and video SDKs can be applied, we import them into the file index.scss:

@layer default-chat-sdk {
  @import 'stream-chat-react/dist/scss/v2/index.scss';
}

@import '@stream-io/video-react-sdk/dist/css/styles.css' layer(default-video-sdk);


File index.scss is then imported into App.tsx. Additionally, we add StreamTheme component to wrap the app in an element carrying CSS class str-video. This will make sure all the variables and styles are applied to the child components:

import type { UserResponse } from 'stream-chat';
import { Chat } from 'stream-chat-react';
import { StreamTheme, StreamVideo } from '@stream-io/video-react-sdk';
import { Channel } from './components/Channel';
import { Sidebar } from './components/Sidebar';
import { Video } from './components/Video';
import { useCreateChatClient } from './hooks';


import './styles/index.scss';


import type { StreamChatType } from './types/chat';

const Root = ({
  apiKey,
  user,
  userToken,
}: {
  apiKey: string;
  user: UserResponse<StreamChatType>;
  userToken: string;
}) => {
  // create clients and connect users

  return (

    <StreamTheme as="main" className="main-container">

      <Chat client={chatClient}>
        <StreamVideo client={videoClient}>
          <Sidebar user={user} />
          <Channel />
          <Video />
        </StreamVideo>
      </Chat>
      {/*// highlight-next-line*/}
    </StreamTheme>
  );
};

Feedback
Previous
Video & Audio filters
Next
Events
Did you find this page helpful?
Section:
Chat Integration
SUBMIT
Project setup and prerequisites
App boilerplate
Initiating chat and video clients
Initiating a ring call
Handling the ring call states
Observing the calls pool state
Observing the state of a specific call
Terminating a call
Adding default styles

Events

In most cases, you can simply use the reactive state store to be notified about state changes. However, for some advanced use cases, you might need to subscribe to the underlying WebSocket events.

Feedback
List of events
â€‹
Client events
â€‹

Client events are always delivered if a user is connected to the client using the connectUser method.

The list of client events:

Name	Description
connection.ok	Fired when the authentication process finished successfully
connection.error	Fired when the WS connections fails
Call events
â€‹

These events are related to a specific call. Some of these events are only delivered to clients that are watching the specific call. There are 3 ways to watch a call:

Call the queryCalls method with the watch option set to true:
import { StreamVideoClient } from '@stream-io/video-react-sdk';

let client: StreamVideoClient;

await client.queryCalls({
  // ...
  watch: true,
});

Join a call:
import { StreamVideoClient } from '@stream-io/video-react-sdk';

let client: StreamVideoClient;

await client.call('default', 'test-call').join();

Watch a call:
import { StreamVideoClient } from '@stream-io/video-react-sdk';

let client: StreamVideoClient;

await client.call('default', 'test-call').getOrCreate();
// or
await client.call('default', 'test-call').get();


The list of call events:

Name	Description	Delivered to
call.accepted	A user accepts a notification to join a call	All call members
call.blocked_user	A user is blocked from the call	Call watchers
call.created	The call was created	All call members
call.ended	The call was ended	All call members
call.hls_broadcasting_failed	The call failed to broadcast	Call watchers
call.hls_broadcasting_started	The call started to broadcast	Call watchers
call.hls_broadcasting_stopped	The call stopped broadcasting	Call watchers
call.live_started	The call left backstage mode	Call watchers
call.member_added	One or more members were added to the call	All call members
call.member_removed	One or more members were removed from the call	All call members
call.member_updated	One or more members were updated	All call members
call.member_updated_permission	One or more members' role was updated	All call members
call.notification	A user is calling all call members	All call members
call.permission_request	A user is requesting permissions	Call watchers
call.permissions_updated	A member's permissions were updated	Call watchers
call.reaction_new	A new reaction was sent	Call watchers
call.recording_failed	A recording failed	Call watchers
call.recording_ready	A recording is ready	Call watchers
call.recording_started	A recording has been started	Call watchers
call.recording_stopped	The recording was stopped	Call watchers
call.rejected	A user declined to join the call	All call members
call.ring	A user is calling all call members	All call members
call.session_ended	A call session ended (all participants have left the call)	Call watchers
call.session_participant_joined	A participant joined to the call sessions	Call watchers
call.session_participant_left	A participant left a call session	Call watchers
call.session_started	A call session started (the first participant joined the call)	Call watchers
call.unblocked_user	A user is unblocked	Call watchers
call.updated	The call was updated	Call watchers
custom	Custom event	All call members
Feedback
Listening to client and call events
â€‹

You can use the on method of the StreamVideoClient instance to subscribe to client and call WebSocket events.

The on method takes the type of the event you want to subscribe to or the 'all' keyword indicating that you want to be notified about all events.

The event handler will receive an object with type StreamVideoEvent that has a type attribute that tells the type of the event. The available event types are described by the EventTypes type.

The on method returns a method that can be called to unsubscribe from WebSocket events.

Subscribing to all events:

import {
  StreamVideoClient,
  StreamVideoEvent,
} from '@stream-io/video-react-sdk';

let client: StreamVideoClient;

// Subscribe to all events
const unsubscribe = client.on('all', (event: StreamVideoEvent) => {
  console.log(event);
});

// Unsubscribe
unsubscribe();


Subscribing to call.created events:

import {
  StreamVideoClient,
  StreamVideoEvent,
} from '@stream-io/video-react-sdk';

let client: StreamVideoClient;

// Subscribe to all events
const unsubscribe = client.on('call.created', (event: StreamVideoEvent) => {
  if (event.type === 'call.created') {
    console.log(`Call created: ${event.call_cid}`);
  }
});

// Unsubscribe
unsubscribe();

Feedback
Listening to call events
â€‹

You can use the on method of the call instance to subscribe to WebSocket events belonging to a specific call.

The call.on method takes the type of the event you want to subscribe to. The event handler will receive an object with type StreamCallEvent that has a type attribute that tells the type of the event. The available event types are described by the CallEventTypes type. The call.on method returns a method that can be called to unsubscribe from WebSocket events.

Example: Subscribing to call.reaction_new event:

import { Call, StreamVideoEvent } from '@stream-io/video-react-sdk';

let call: Call;

// Subscribe to new reactions event
const unsubscribe = call.on('call.reaction_new', (event: StreamVideoEvent) => {
  if (event.type === 'call.reaction_new') {
    console.log(`New reaction: ${event.reaction}`);
  }
});

// Unsubscribe
unsubscribe();

Feedback
Custom events
â€‹

You can send custom events between the call participants using the sendCustomEvent method of the call instance. Note that the payload for these events is limited to 5KB in size.

import {
  Call,
  CustomVideoEvent,
  StreamVideoEvent,
} from '@stream-io/video-react-sdk';

let call: Call;

// sending a custom event
await call.sendCustomEvent({
  type: 'my-event-type',
  payload: {
    foo: 'bar',
  },
});

// receiving a custom event
call.on('custom', (event: StreamVideoEvent) => {
  const customEvent = event as CustomVideoEvent;
  const payload = customEvent.custom;
  if (payload.type === 'my-event-type') {
    console.log(payload.foo);
  }
});

Feedback
Previous
Chat Integration
Next
GDPR Endpoints
Did you find this page helpful?
Section:
Events
SUBMIT
List of events
Client events
Call events
Listening to client and call events
Listening to call events
Custom events

Video & Audio filters
Feedback
Apply Custom Video Filters
â€‹

This feature is coming soon...

Feedback
Previous
Joining a call from a link
Next
Chat Integration
Did you find this page helpful?
Section:
Video & Audio filters
SUBMIT
Apply Custom Video Filters

Internationalization

The SDK comes with a built-in translation service powered internally by the i18next library. The main focus of the service is to provide support for:

Switching the language
Easy addition of custom translations in any language mutation
Access to underlying i18n instance from i18next library and thus have access to the library's API

Also, the SDK already provides default translations for the available components.

Feedback
Integration
â€‹

The service is made available through the StreamVideo provider. That means that all the child components of this provider can access the StreamI18nContextValue object by using the useI18n context consumer.

The StreamI18nContextValue carries the following properties:

the translator function t - expects to receive a string to translate and returns its translation or the original value, if no translation for the given key and language could be found.
the StreamI18n instance - allows for more control over the service

It is also possible to use StreamI18nProvider without the StreamVideo provider. Again, all the child components of this provider can access the StreamI18nContextValue object by using the useI18n context consumer.

Configuration
â€‹

What ends up in the StreamI18nContextValue depends on what configuration parameters we provide to the StreamI18nProvider. These are:

type StreamI18nProviderProps = {
  i18nInstance?: StreamI18n;
  language?: string;
  translationsOverrides?: TranslationsMap;
};

NOTE

StreamVideo internally forwards these parameters to StreamI18nProvider.

In the following sections, we will look more into these individual configuration parameters.

Custom translations
â€‹

In case you would like to add to or change the default translations, you can use the translationsOverrides prop. This should be an object that will match the type TranslationsMap.

type TranslationsMap = Record<TranslationLanguage, TranslationSheet>;

type TranslationLanguage = keyof typeof defaultTranslations | string;

type TranslationSheet = typeof defaultTranslations.en | Record<string, string>;


The translations are merged with the SDK's defaults. That means that the defaults are overridden or new keys are added to the translation sheets.

const translations = {
  en: {
    // ...
    terminate: 'terminate',
    // ...
  },
  de: {
    // ...
    terminate: 'beended',
    // ...
  },
  // ...
};

const App = () => {
  // ...
  return (
    <StreamVideo client={client} translationsOverrides={translations}>
      // ...
    </StreamVideo>
  );
};

Provide your own instance of
StreamI18n
â€‹

You may want to initialize the service somewhere else and pass the instance through the prop i18nInstance. If an instance of StreamI18n is provided, it will be forwarded to the context without any changes.

type CreateI18nParams = {
  language?: string;
  translationsOverrides?: TranslationsMap;
};

const useCreateI18n = ({
  language,
  translationsOverrides,
}: CreateI18nParams) => {
  const i18nRef = useRef(
    new StreamI18n({ currentLanguage: language, translationsOverrides }),
  );

  useEffect(() => {
    const i18n = i18nRef.current;
    if (i18n.isInitialized && language && i18n?.currentLanguage !== language) {
      i18n.changeLanguage(language);
    } else if (!i18n.isInitialized) {
      // sets the default language
      if (!language) i18n.changeLanguage();
      i18n.init();
    }
  }, [language, translationsOverrides]);

  return i18n;
};

const App = () => {
  const i18n = useCreateI18n();

  return (
    <StreamVideo client={client} i18nInstance={i18n}>
      ...
    </StreamVideo>
  );
};

Language
â€‹

You can set the current language for the translation service with language prop. This should be a language code (for example en, de etc.) that matches a key in translationsOverrides or is among the SDK's default language mutations which are specified by the type TranslationLanguage.

const App = () => {
  /*  a hook that keeps track of the current language in your app  */
  const { language, setLanguage } = useLanguage();
  // ...
  return (
    <StreamVideo
      client={client}
      language={language}
      translationsOverrides={translations}
    >
      {/*...*/}
    </StreamVideo>
  );
};

Feedback
Translation function
â€‹

This is the central feature of the service. The function is passed a string we want to translate and returns its translation. If the translated key is not found, then the returned value is the original string. We rely on the translation function provided by the library i18next. This function is exposed on StreamI18n object
as well as in the StreamI18nContextValue.
.

Accessing the translation function
â€‹

You can access the translation function in any child component of StreamVideo resp. StreamI18nProvider through the context consumer useI18n:

import { useI18n } from '@stream-io/video-react-sdk';

const CustomButton = () => {
  const { t } = useI18n();

  return <button>{t('Submit')}</button>;
};

Feedback
Final recommendations
â€‹

As the translation service is based on i18next which i18n instance is made available through StreamI18n, we encourage you to consult the library's documentation in order to learn about:

the use of the translation function
how to dynamically insert text with interpolation documentation article
how to format interpolated value i18next's formatting guide
how to specify different plural forms with the pluralization guide
Feedback
Previous
Watching a livestream
Next
Joining a call from a link
Did you find this page helpful?
Section:
Internationalization
SUBMIT
Integration
Configuration
Translation function
Accessing the translation function
Final recommendations

Joining a call from a link

Many video calling apps that offer video and audio conferencing features, support joining a call from a link. This is a great way to allow users to join a call without having to go through many complex steps.

In the next few steps, we will show how such a flow can be implemented using the Stream's React Video SDKs.

Feedback
Define the URL structure
â€‹

The first step is to define the URL structure that will be used to join a call. Typically, the URL will contain the following information:

your app's domain
an optional route pointing to the calling features of your app
the call ID
optional call type information, in case your app supports multiple call types

In our example, we will use the following URL structure:

https://myapp.com/join?call_id=123&call_type=default
Feedback
Get call information and join a call
â€‹

Once the user opens the link, your app needs to read the call ID and call type from the URL as they are required parameters for our SDK. Next, we will use the call information to setup and join the call.

In the example below, we will use standard browser APIs to read the call ID and call type from the URL.

import {
  CallControls,
  SpeakerLayout,
  StreamCall,
  StreamVideo,
  StreamVideoClient,
} from '@stream-io/video-react-sdk';

const urlParams = new URLSearchParams(window.location.search);
const callId = urlParams.get('call_id');
const callType = urlParams.get('call_type') || 'default'; // or your custom call type

// initialize the client, call and join the call
const client = new StreamVideoClient({ apiKey, user, token });
const call = client.call(callType, callId);
await call.join();

export const MyCallingApp = () => {
  return (
    <StreamVideo client={client}>
      <StreamCall call={call}>
        <SpeakerLayout />
        <CallControls />
      </StreamCall>
    </StreamVideo>
  );
};

Feedback
Integration popular routing libraries
â€‹

In the React ecosystem, there are many routing libraries that can be used to handle routing in your app. In the next few steps, we will show how you can integrate the Stream's React Video SDKs with some of the most popular routing libraries.

React Router
â€‹

React Router provides a useParams hook that can be used to read the call ID and call type from the URL.

Next.js Router
â€‹

Next.js provides a useRouter hook that can be used to read the call ID and call type from the URL.

Alternatively, you can use the useParams hook in case it is more convenient for your use case.

Feedback
Previous
Internationalization
Next
Video & Audio filters
Did you find this page helpful?
Section:
Joining a call from a link
SUBMIT
Define the URL structure
Get call information and join a call
Integration popular routing libraries
React Router
Next.js Router

Watching a livestream

As already described in our livestream tutorial, there are two ways how a livestream can be watched: either via HLS or via WebRTC.

This guide describes how to watch a livestream via WebRTC.

Our React Video SDK provides a specialized LivestreamLayout component for this purpose. Right next to playing the livestream, it also provides a standardized livestreaming experience:

Shows a "Live" indicator badge
Shows the current viewer count
Shows the duration of the livestream
Allows toggling between fullscreen and normal mode

Here is a preview of the LivestreamLayout component in video mode:

And, in screen share mode:

Feedback
Usage
â€‹
import {
  LivestreamLayout,
  StreamVideo,
  StreamCall,
} from '@stream-io/video-react-sdk';

export const MyLivestreamApp = () => {
  // init client and call here...
  return (
    <StreamVideo client={client}>
      <StreamCall call={call}>
        <LivestreamLayout
          muted={false}
          enableFullscreen={true}
          showParticipantCount={true}
          showDuration={true}
          showLiveBadge={true}
          showSpeakerName={false}
          floatingParticipantProps={{
            muted: false,
            enableFullscreen: true,
            showParticipantCount: true,
            showDuration: true,
            showLiveBadge: true,
            showSpeakerName: false,
            position: 'top-right',
          }}
        />
      </StreamCall>
    </StreamVideo>
  );
};


Note: Please make sure that the livestream is started and the call isn't in backstage mode before rendering this component.

Customization options
â€‹

The LivestreamLayout component provides a few customization options that can be passed as props:

muted - a boolean flag that indicates whether the livestream should be muted or not. Defaults to false.
enableFullscreen - a boolean flag that indicates whether the fullscreen button should be shown or not. Defaults to true.
showParticipantCount- a boolean flag that indicates whether the current viewer count should be shown or not. Defaults to true.
showDuration - a boolean flag that indicates whether the duration of the livestream should be shown or not. Defaults to true.
showLiveBadge- a boolean flag that indicates whether the "Live" badge should be shown or not. Defaults to true.
showSpeakerName - a boolean flag that indicates whether the speaker should be shown or not. Defaults to false.
floatingParticipantProps - an optional object that contains props that should be passed to the "Floating Participant" component in screen-share mode. They are identical to the props of the LivestreamLayout component props.
floatingParticipantProps.position - a string that indicates the position of the "Floating Participant" component. Can be either top-left, top-right, bottom-left or bottom-right. Defaults to top-right.
Feedback
Previous
Runtime layout switching
Next
Internationalization
Did you find this page helpful?
Section:
Watching a livestream
SUBMIT
Usage
Customization options

Connection Unstable

Besides showing the quality of user's network connection, another useful video call feature is to indicate unreliable participant's connection quality. The default ParticipantViewUI does this by rendering SDK's Notification component when the connection quality reaches poor level.

Our minimal custom unstable connection notification should look as follows:

import {
  SfuModels,
  useParticipantViewContext,
} from '@stream-io/video-react-sdk';

const PoorConnectionNotification = () => {
  const { participant } = useParticipantViewContext();
  const { connectionQuality, isLocalParticipant } = participant;

  if (
    isLocalParticipant &&
    connectionQuality === SfuModels.ConnectionQuality.POOR
  ) {
    return <div>Poor connection quality</div>;
  }
  return null;
};

export const CustomParticipantViewUI = () => {
  return (
    <>
      <PoorConnectionNotification />
      {/* your other custom UI elements */}
    </>
  );
};

Feedback
Final steps
â€‹

Now we can pass this custom ParticipantViewUI component down to our call layout components or directly to ParticipantView component in our custom call layout as described in the ParticipantView customizations guide.

import { useCallStateHooks, ParticipantView } from '@stream-io/video-react-sdk';

import { CustomParticipantViewUI } from '../ParticipantViewUI';
import { CustomVideoPlaceholder } from '../VideoPlaceholder';

export const CustomCallLayout = () => {
  const { useParticipants } = useCallStateHooks();
  const otherParticipants = useParticipants();

  return (
    <div>
      {/* your other custom UI elements */}
      {otherParticipants.map((participant) => (
        <div key={participant.sessionId}>
          <ParticipantView
            participant={participant}

            ParticipantViewUI={CustomParticipantViewUI}

            VideoPlaceholder={CustomVideoPlaceholder}
          />
        </div>
      ))}
    </div>
  );
};

Feedback
Previous
Speaking While Muted
Next
ParticipantView customizations
Did you find this page helpful?
Section:
Connection Unstable
SUBMIT
Final steps

Runtime layout switching

During your application's lifecycle there will be situations where you'll want to direct your users to a different video layout upon certain event. In this case we'll explore how to automatically switch to a video layout that is better suited for when any of the participants starts a screen share session.

Feedback
Defining Stage component
â€‹

In this guide, we'll introduce a concept component called Stage that'll handle the automatic switching logic and renders appropriate layout component.

import {
  PaginatedGridLayout,
  SpeakerLayout,
  useCallStateHooks,
} from '@stream-io/video-react-sdk';

const LayoutMap = {
  Speaker: {
    component: SpeakerLayout,
    title: 'Speaker layout with spotlight',
    props: {},
  },
  PaginatedGrid: {
    component: PaginatedGridLayout,
    title: 'Paginated grid layout',
    props: {
      groupSize: 12,
    },
  },
};

export const Stage = () => {
  const [selectedLayout, setSelectedLayout] =
    useState<keyof typeof LayoutMap>('PaginatedGrid');
  const { useHasOngoingScreenshare } = useCallStateHooks();
  const hasOngoingScreenshare = useHasOngoingScreenshare();

  const LayoutComponent = LayoutMap[selectedLayout].component;
  const componentProps = LayoutMap[selectedLayout].props;

  useEffect(() => {
    // set screen share compatible layout
    if (hasOngoingScreenshare) return setSelectedLayout('Speaker');

    return setSelectedLayout('PaginatedGrid');
  }, [hasOngoingScreenshare]);

  return <LayoutComponent {...componentProps} />;
};

Optional enhancements
â€‹

If your application supports more than two video layouts, you might want to consider storing preferred layout in the localStorage so when your application toggles back - it switches to the preferred one.

Consider using versioned persisted application states like the one in Zustand.

Feedback
Previous
ParticipantView customizations
Next
Watching a livestream
Did you find this page helpful?
Section:
Runtime layout switching
SUBMIT
Defining Stage component
Optional enhancements

ParticipantView customizations

In this guide, you'll learn how to customize default call layouts and how to apply custom video placeholder and UI components to the ParticipantView component. We recommend using the ParticipantView component provided by the SDK because it handles rendering your video. It also manages video quality updates, subscriptions, and visibility state when the element is not in the visible viewport. By following this guide, you'll be able to tailor the call layouts and visual elements according to your specific needs while leveraging the capabilities provided by the ParticipantView component.

Feedback
ParticipantViewUI and VideoPlaceholder templates
â€‹

ParticipantView comes by default with certain participant information displayed in the "box" - such as mute states of either video or audio, quality indicator, participant's name, reactions, etc. which are displayed over the video element positioned absolutely (see picture). By utilizing the ParticipantViewUI property, we can extend the ParticipantView component with custom UI elements specific to each participant. This allows us to tailor the visual representation of the participant based on our application's requirements and design.

The VideoPlaceholder property allows us to replace the default placeholder displayed over the video element when the video is not playing. This placeholder is positioned absolutely over the video element. It provides us with the flexibility to customize the placeholder's appearance and content according to our needs.

CAUTION

Our custom VideoPlaceholder component should be able to accept a style property coming from ParticipantView to allow for absolute positioning.

Feedback
Customization in SDK provided layout components (preferred way)
â€‹

We highly recommend using layout components provided by the SDK as it is possible to modify the ParticipantViewUI in these call layouts. You can follow this guide to build your own call layout.

PaginatedGridLayout
â€‹

Call layout for large calls where ParticipantView elements are equally sized, you have the ability to customize the ParticipantViewUI and VideoPlaceholder components using their respective properties of this component.

import {
  PaginatedGridLayout,
  StreamVideo,
  StreamCall,
  useParticipantViewContext,
  type VideoPlaceholderProps,
} from '@stream-io/video-react-sdk';

const CustomParticipantViewUI = () => {
  const { participant } = useParticipantViewContext();

  return (
    <div className="participant-name">{participant.name || participant.id}</div>
  );
};

const CustomVideoPlaceholder = ({ style }: VideoPlaceholderProps) => {
  const { participant } = useParticipantViewContext();

  return (
    <div className="video-placeholder" style={style}>
      <img src={participant.image} alt={participant.id} />
    </div>
  );
};

const App = ({ client, callId }) => {
  return (
    <StreamVideo client={client}>
      <StreamCall callId={callId}>
        <PaginatedGridLayout
          VideoPlaceholder={CustomVideoPlaceholder}
          ParticipantViewUI={CustomParticipantViewUI}
        />
      </StreamCall>
    </StreamVideo>
  );
};

SpeakerLayout
â€‹

The SpeakerLayout component allows you to tweak participant UI in the spotlight and in the scrollable bar independently.

import {
  SpeakerLayout,
  StreamVideo,
  StreamCall,
  useParticipantViewContext,
  type VideoPlaceholderProps,
} from '@stream-io/video-react-sdk';

const CustomParticipantViewUIBar = () => {
  const { participant } = useParticipantViewContext();

  return (
    <div className="bar-participant-name">
      {participant.name || participant.id}
    </div>
  );
};

const CustomParticipantViewUISpotlight = () => {
  const { participant } = useParticipantViewContext();

  return (
    <div className="spotlight-participant-name">
      {participant.name || participant.id}
    </div>
  );
};

const CustomVideoPlaceholder = ({ style }: VideoPlaceholderProps) => {
  const { participant } = useParticipantViewContext();

  return (
    <div className="video-placeholder" style={style}>
      <img src={participant.image} alt={participant.id} />
    </div>
  );
};

const App = ({ client, callId }) => {
  return (
    <StreamVideo client={client}>
      <StreamCall callId={callId}>
        <SpeakerLayout
          VideoPlaceholder={CustomVideoPlaceholder}
          ParticipantViewUIBar={CustomParticipantViewUIBar}
          ParticipantViewUISpotlight={CustomParticipantViewUISpotlight}
        />
      </StreamCall>
    </StreamVideo>
  );
};

Feedback
Standalone ParticipantView customization (in custom call layouts)
â€‹

The ParticipantViewUI property accepts three possible values:

ReactElement - find out what's considered a ReactElement in the React documentation
component which can access ParticipantView related data through useParticipantViewContext hook
null if you wish to not render any UI

The following example shows the utilization of the ParticipantViewUI prop by passing down ReactElement:

import { type PropsWithChildren } from 'react';
import {
  type VideoPlaceholderProps,
  ParticipantView,
  useCallStateHooks,
  useParticipantViewContext,
} from '@stream-io/video-react-sdk';

const CustomVideoPlaceholder = ({ style }: VideoPlaceholderProps) => {
  const { participant } = useParticipantViewContext();

  return (
    <div className="video-placeholder" style={style}>
      <img src={participant.image} alt={participant.id} />
    </div>
  );
};

const CustomParticipantViewUI = ({ children }: PropsWithChildren) => {
  return <div className="participant-name">{children}</div>;
};

const CustomCallLayout = () => {
  const { useParticipants } = useCallStateHooks();
  const participants = useParticipants();

  return (
    <div className="custom-call-layout">
      {participants.map((participant) => (
        <ParticipantView
          key={participant.sessionId}
          VideoPlaceholder={CustomVideoPlaceholder}
          ParticipantViewUI={
            <CustomParticipantViewUI>
              {participant.name || participant.id}
            </CustomParticipantViewUI>
          }
        />
      ))}
    </div>
  );
};

Feedback
Previous
Connection Unstable
Next
Runtime layout switching
Did you find this page helpful?
Section:
ParticipantView customizations
SUBMIT
ParticipantViewUI and VideoPlaceholder templates
Customization in SDK provided layout components (preferred way)
PaginatedGridLayout
SpeakerLayout
Standalone ParticipantView customization (in custom call layouts)

Speaking While Muted

In this cookbook, we will explore the ways to remind users they are speaking while being muted. The React SDK bundles SpeakingWhileMutedNotification component, but we will discover how to build our own component.

Feedback
Speaking-while-muted notification component
â€‹

Our speaking-while-muted notification component will be based on simple principle of reading the isSpeakingWhileMuted state of the currently selected mic. The UI will be rendered only, when isSpeakingWhileMuted is set to true.

import { useCallStateHooks } from '@stream-io/video-react-sdk';

export const SpeakingWhileMutedNotification = () => {
  const { useMicrophoneState } = useCallStateHooks();
  const { isSpeakingWhileMuted } = useMicrophoneState();

  if (!isSpeakingWhileMuted) return null;
  return <div>You are muted</div>;
};

Feedback
Previous
Network Quality Indicator
Next
Connection Unstable
Did you find this page helpful?
Section:
Speaking While Muted
SUBMIT
Speaking-while-muted notification component

Network Quality Indicator

Network conditions are not always perfect so instead of playing guessing games as to why is someone's video so blurry our default ParticipantViewUI component comes equipped with connection quality indicator which provides general information about that participants network conditions in four states:

unspecified
poor
good
excellent

In this guide we'll learn how to build and implement our own primitive connection quality indicator.

How to reach the state
â€‹

Each StreamVideoParticipant has a connectionQuality property which by itself is just a numeric representation of values in a SfuModels.ConnectionQuality enum. To get a readable format out of it we'll just pass the connectionQuality variable as a key to said enum:

import { SfuModels } from '@stream-io/video-react-sdk';

const readableConnectionQuality =
  SfuModels.ConnectionQuality[participant.connectionQuality];

console.log(readableConnectionQuality); // -> EXCELLENT

Network quality indicator component
â€‹

You'll most likely be displaying this indicator component inside each participant box (ParticipantView) within a call layout, you can learn more about ParticipantViewUI customizations in the participant view customizations guide.

import {
  SfuModels,
  useParticipantViewContext,
} from '@stream-io/video-react-sdk';

const MyNetworkQualityIndicator = () => {
  const { participant } = useParticipantViewContext();

  const readableConnectionQuality =
    SfuModels.ConnectionQuality[participant.connectionQuality];

  return (
    <span title={readableConnectionQuality}>
      {'â­ï¸'.repeat(participant.connectionQuality)}
    </span>
  );
};

const CustomParticipantViewUI = () => {
  return (
    <>
      <MyNetworkQualityIndicator />
      {/* your other custom UI elements */}
    </>
  );
};

Feedback
Final steps
â€‹

Now we can pass this custom ParticipantViewUI component down to our call layout components or directly to ParticipantView component in our custom call layout as described in the aforementioned ParticipantView customizations guide.

Feedback
Previous
Audio Volume Indicator
Next
Speaking While Muted
Did you find this page helpful?
Section:
Network Quality Indicator
SUBMIT
How to reach the state
Network quality indicator component
Final steps

Audio Volume Indicator

In this documentation article, we will explore how to build a custom sound detection component by using useMicrophoneState() and our createSoundDetector() helper.

Feedback
AudioVolumeIndicator component
â€‹

The component will show the audio level changes by expanding and contracting a line.

The audio level is kept in component's state. The sound detection is set up in an effect. Also, we make sure to call the clean-up function in the effect clean-up phase.

import { useEffect, useState } from 'react';

import {
  createSoundDetector,
  Icon,
  useCallStateHooks,
} from '@stream-io/video-react-sdk';

export const AudioVolumeIndicator = () => {
  const { useMicrophoneState } = useCallStateHooks();
  const { isEnabled, mediaStream } = useMicrophoneState();
  const [audioLevel, setAudioLevel] = useState(0);

  useEffect(() => {
    if (!isEnabled || !mediaStream) return;

    const disposeSoundDetector = createSoundDetector(
      mediaStream,
      ({ audioLevel: al }) => setAudioLevel(al),
      { detectionFrequencyInMs: 80, destroyStreamOnStop: false },
    );

    return () => {
      disposeSoundDetector().catch(console.error);
    };
  }, [isEnabled, mediaStream]);

  if (!isEnabled) return null;

  return (
    <div
      style={{
        width: '100%',
        display: 'flex',
        alignItems: 'center',
        gap: '0.75rem',
        padding: '0 1.25rem 1rem',
      }}
    >
      <Icon icon="mic" />
      <div
        style={{
          flex: '1',
          background: '#fff',
          height: '5px',
          borderRadius: '4px',
        }}
      >
        <div
          style={{

            transform: `scaleX(${audioLevel / 100})`,

            transformOrigin: 'left center',

            background: 'var(--str-video__primary-color)',
            width: '100%',
            height: '100%',
          }}
        />
      </div>
    </div>
  );
};

Feedback
Previous
Permission Requests
Next
Network Quality Indicator
Did you find this page helpful?
Section:
Audio Volume Indicator
SUBMIT
AudioVolumeIndicator component

Permission Requests

Permission requests allow call participants to request permission to publish audio/video/screen-share. Participants with elevated permissions can accept or reject these requests. This guide shows you how you can build a UI for sending and receiving these requests.

NOTE

The ToggleVideoPublishingButton, ToggleAudioPublishingButton and ScreenShareButton components can send permission requests, you only need to follow this guide if you want to build your own UI for this.

The PermissionRequests component can receive permission requests, you only need to follow this guide if you want to build your own UI for this.

Feedback
Prerequisites
â€‹

Before we can join a call, we need to connect to Stream's edge infrastructure. To do that, we follow these steps:

Register for a Stream account and obtain our API key and secret.
Install the Stream React Video SDK:
npm install @stream-io/video-react-sdk
yarn add @stream-io/video-react-sdk
Initialize the SDK by passing in your API key, token and user information
Create and join a call
Feedback
Start point
â€‹

Let's start with a simple call UI where we create an audio_room call.

import {
  StreamVideo,
  StreamCall,
  SpeakerLayout,
  CallControls,
  useCall,
  StreamTheme,
} from '@stream-io/video-react-sdk';
import '@stream-io/video-react-sdk/dist/css/styles.css';

export default function App() {
  // create client and call

  return (
    <StreamTheme>
      <StreamVideo client={client}>
        <StreamCall call={call}>
          <MyCallUI />
        </StreamCall>
      </StreamVideo>
    </StreamTheme>
  );
}

const MyCallUI = () => {
  const call = useCall();
  return (
    <div>
      <MyPermissionRequestNotifications />
      <SpeakerLayout />
      <CallControls />
      <MyPermissionRequests />
    </div>
  );
};

const MyPermissionRequests = () => {};

const MyPermissionRequestNotifications = () => {};

NOTE

Permission requests are only relevant for call types that have roles where a participant can't publish their audio/video/screen-share by default.

In this guide, we will implement the PermissionRequests component to send permission requests and the PermissionRequestNotifications to receive them.

To follow along with the guide, don't forget to turn off backstage mode so others can join:

let call: Call;

await call.goLive();

Feedback
Request permission
â€‹

In this step we will implement the MyPermissionRequests and the MyPermissionRequestButton components to send permission requests.

For readability the code snippet only contains the MyPermissionRequests and the MyPermissionRequestButton implementation, the full example is available at the end of the guide.

import {
  useRequestPermission,
  useCallStateHooks,
  OwnCapability,
} from '@stream-io/video-react-sdk';

const MyPermissionRequestButton = ({ children, capability }) => {
  const {
    requestPermission,
    hasPermission,
    canRequestPermission,
    isAwaitingPermission,
  } = useRequestPermission(capability);

  if (hasPermission || !canRequestPermission) return null;

  return (
    <button disabled={isAwaitingPermission} onClick={() => requestPermission()}>
      {children}
    </button>
  );
};

const MyPermissionRequests = () => {
  const call = useCall();
  const { useHasPermissions } = useCallStateHooks();
  const canSendAudio = useHasPermissions(OwnCapability.SEND_AUDIO);
  const canSendVideo = useHasPermissions(OwnCapability.SEND_VIDEO);
  const canShareScreen = useHasPermissions(OwnCapability.SCREENSHARE);

  if (!call) {
    return null;
  }

  return (
    <div>
      <MyPermissionRequestButton capability={OwnCapability.SEND_AUDIO}>
        Request audio permission
      </MyPermissionRequestButton>
      <MyPermissionRequestButton capability={OwnCapability.SEND_VIDEO}>
        Request video permission
      </MyPermissionRequestButton>
      <MyPermissionRequestButton capability={OwnCapability.SCREENSHARE}>
        Request screen share permission
      </MyPermissionRequestButton>
      {canSendAudio ? 'Allowed to send audio' : 'Not allowed to send audio'}
      {canSendVideo ? 'Allowed to send video' : 'Not allowed to send video'}
      {canShareScreen
        ? 'Allowed to share screen'
        : 'Not allowed to share screen'}
    </div>
  );
};


Let's unpack the above code snippet:

We only display the request button if the user is allowed to request the specific capability and doesn't already have that permission. For more information, check out the permissions guide.
To send the request we are using the requestPermission function (wrapper around requestPermissions method of the Call instance) which comes from the useRequestPermission hook.
We use the useHasPermissions hook to be notified when the request was approved. Alternatively you can subscribe to the call.permissions_updated event.
Feedback
Receive permission requests
â€‹

In this step we will implement the MyPermissionRequestNotifications component to receive permission requests.

For readability, the code snippet only contains the MyPermissionRequestNotifications implementation, the full example is available at the end of the guide.

const MyPermissionRequestNotifications = () => {
  const call = useCall();
  const { useLocalParticipant, useHasPermissions } = useCallStateHooks();
  const localParticipant = useLocalParticipant();
  const canUpdateCallPermissions = useHasPermissions(
    OwnCapability.UPDATE_CALL_PERMISSIONS,
  );
  const [permissionRequests, setPermissionRequests] = useState([]);

  useEffect(() => {
    if (!call || !canUpdateCallPermissions) return;

    const unsubscribe = call.on(
      'call.permission_request',
      (event: StreamVideoEvent) => {
        // ignore own requests
        if (event.user.id !== localParticipant?.userId) {
          setPermissionRequests((requests) => [
            ...requests,
            event as PermissionRequestEvent,
          ]);
        }
      },
    );
    return () => {
      unsubscribe();
    };
  }, [call, canUpdateCallPermissions, localParticipant]);

  if (!call || permissionRequests.length === 0) {
    return null;
  }

  const answerRequest = async (answer, request) => {
    if (answer === 'accept') {
      await call.grantPermissions(request.user.id, request.permissions);
    } else {
      await call.revokePermissions(request.user.id, request.permissions);
    }
    setPermissionRequests((requests) => requests.filter((r) => r !== request));
  };

  return (
    <div>
      {permissionRequests.map((request) => (
        <div>
          New request from {request.user.id} to publish {request.permissions}
          <button onClick={() => answerRequest('accept', request)}>
            Accept
          </button>
          <button onClick={() => answerRequest('reject', request)}>
            Reject
          </button>
        </div>
      ))}
    </div>
  );
};


Let's unpack the above code snippet:

We only show the permission requests to users that have the necessary capability to accept/reject: call.hasPermission(OwnCapability.UPDATE_CALL_PERMISSIONS)
We subscribe to listen to 'call.permission_request' WS event to update the list of requests
A permission request can be accepted with the grantPermissions method of the Call instance
A permission request can be rejected with the revokePermissions method of the Call instance. This method can also be used to revoke permissions later in the call.
Feedback
Finished example
â€‹

Here is the full example:

import {
  CallControls,
  CallParticipantsView,
  OwnCapability,
  PermissionRequestEvent,
  StreamCall,
  StreamTheme,
  StreamVideo,
  StreamVideoEvent,
  useCall,
  useCallStateHooks,
  useRequestPermission,
} from '@stream-io/video-react-sdk';
import '@stream-io/video-react-sdk/dist/css/styles.css';
import { useEffect, useState } from 'react';

export default function App() {
  // create client and call

  return (
    <StreamTheme>
      <StreamVideo client={client}>
        <StreamCall call={call}>
          <MyCallUI />
        </StreamCall>
      </StreamVideo>
    </StreamTheme>
  );
}

const MyCallUI = () => {
  const call = useCall();

  return (
    <div>
      <MyPermissionRequestNotifications />
      <CallParticipantsView call={call} />
      <CallControls />
      <MyPermissionRequests />
    </div>
  );
};

const MyPermissionRequestButton = ({ children, capability }) => {
  const {
    requestPermission,
    hasPermission,
    canRequestPermission,
    isAwaitingPermission,
  } = useRequestPermission(capability);

  if (hasPermission || !canRequestPermission) return null;

  return (
    <button disabled={isAwaitingPermission} onClick={() => requestPermission()}>
      {children}
    </button>
  );
};

const MyPermissionRequests = () => {
  const call = useCall();
  const { useHasPermissions } = useCallStateHooks();
  const canSendAudio = useHasPermissions(OwnCapability.SEND_AUDIO);
  const canSendVideo = useHasPermissions(OwnCapability.SEND_VIDEO);
  const canShareScreen = useHasPermissions(OwnCapability.SCREENSHARE);

  if (!call) {
    return null;
  }

  return (
    <div>
      <MyPermissionRequestButton capability={OwnCapability.SEND_AUDIO}>
        Request audio permission
      </MyPermissionRequestButton>
      <MyPermissionRequestButton capability={OwnCapability.SEND_VIDEO}>
        Request video permission
      </MyPermissionRequestButton>
      <MyPermissionRequestButton capability={OwnCapability.SCREENSHARE}>
        Request screen share permission
      </MyPermissionRequestButton>
      {canSendAudio ? 'Allowed to send audio' : 'Not allowed to send audio'}
      {canSendVideo ? 'Allowed to send video' : 'Not allowed to send video'}
      {canShareScreen
        ? 'Allowed to share screen'
        : 'Not allowed to share screen'}
    </div>
  );
};

const MyPermissionRequestNotifications = () => {
  const call = useCall();
  const { useLocalParticipant, useHasPermissions } = useCallStateHooks();
  const localParticipant = useLocalParticipant();
  const canUpdateCallPermissions = useHasPermissions(
    OwnCapability.UPDATE_CALL_PERMISSIONS,
  );
  const [permissionRequests, setPermissionRequests] = useState([]);

  useEffect(() => {
    if (!call || !canUpdateCallPermissions) return;

    const unsubscribe = call.on(
      'call.permission_request',
      (event: StreamVideoEvent) => {
        // ignore own requests
        if (event.user.id !== localParticipant?.userId) {
          setPermissionRequests((requests) => [
            ...requests,
            event as PermissionRequestEvent,
          ]);
        }
      },
    );
    return () => {
      unsubscribe();
    };
  }, [call, canUpdateCallPermissions, localParticipant]);

  if (!call || permissionRequests.length === 0) {
    return null;
  }

  const answerRequest = async (answer, request) => {
    if (answer === 'accept') {
      await call.grantPermissions(request.user.id, request.permissions);
    } else {
      await call.revokePermissions(request.user.id, request.permissions);
    }
    setPermissionRequests((requests) => requests.filter((r) => r !== request));
  };

  return (
    <div>
      {permissionRequests.map((request) => (
        <div>
          New request from {request.user.id} to publish {request.permissions}
          <button onClick={() => answerRequest('accept', request)}>
            Accept
          </button>
          <button onClick={() => answerRequest('reject', request)}>
            Reject
          </button>
        </div>
      ))}
    </div>
  );
};

Feedback
Previous
Video Placeholder
Next
Audio Volume Indicator
Did you find this page helpful?
Section:
Permission Requests
SUBMIT
Prerequisites
Start point
Request permission
Receive permission requests
Finished example

Video Placeholder

The VideoPlaceholder component is a combination of elements that serves as a fallback in the absence of an active video feed. This component is conditionally rendered by the ParticipantView core component over the video element, learn how to customize your ParticipantView in the participant view customizations guide.

In this guide we'll learn how to build and implement our own primitive video placeholder component.

Video placeholder component
â€‹
import {
  useParticipantViewContext,
  type VideoPlaceholderProps,
} from '@stream-io/video-react-sdk';

const CustomVideoPlaceholder = ({

  style,

}: VideoPlaceholderProps) => {
  const { participant } = useParticipantViewContext();

  return (

    <div style={{ ...style, width: '100%', background: '#ddd' }}>

      {/* display profile picture if available */}
      {participant.image && (
        <img
          style={{ width: 100, height: 100, borderRadius: 9999 }}
          src={participant.image}
          alt={participant.id}
        />
      )}
      {/* otherwise try to display name or fallback to ID */}
      {!participant.image && <span>{participant.name || participant.id}</span>}
    </div>
  );
};


We've mentioned that VideoPlaceholder component is rendered over the video element. This is done so that the SDK can keep working with the same video element instance for performance reasons. As you can see, we've highlighted a few lines which are recommended way to implement our placeholder component. This extra style property comes from the ParticipantView component and currently only provides absolute positioning but this might be a subject to change so to make future updates easier, we recommend you to extend your "wrapper" element's style with style property provided by the ParticipantView component.

Feedback
Final steps
â€‹

Now we can pass this custom VideoPlaceholder component down to our call layout components or directly to ParticipantView component in our custom call layout as described in the aforementioned ParticipantView customizations guide.

Feedback
Previous
Lobby Preview
Next
Permission Requests
Did you find this page helpful?
Section:
Video Placeholder
SUBMIT
Video placeholder component
Final steps

Lobby Preview

In this article, we will discuss key considerations for creating an inviting and user-friendly entrance to your application. We will delve into the various elements that can enhance the user experience and ensure a smooth transition from the lobby to the video call itself. By implementing effective lobby page design principles, you can elevate the overall user satisfaction. We consider lobby to be place, where the user acquires information about the call to be joined and can configure own media devices.

NOTE

The approach to visualise the components will differ from application to application. Therefore, in this guide, we will focus only on the principles of building components and plugging them with right data sources. We will not focus on the styling (CSS) part.

Feedback
Prerequisites
â€‹

Before we can join a call, we need to connect to Stream's edge infrastructure. To do that, we follow these steps:

Register for a Stream account and obtain our API key and secret.
Install the Stream React Video SDK:
npm install @stream-io/video-react-sdk
yarn add @stream-io/video-react-sdk
Initialize the SDK by passing in your API key, token and user information:
NOTE

For the token generation, you can use our Token Generator.

The call data
â€‹

We would like to show some basic information about the call, when users arrive to the lobby. For example:

call name
who is invited
who already joined

The initial call information can be retrieved by the get or getOrCreate method of a Call instance. Then we can use the following hooks:

useCallSession
useCallMembers

These hooks make sure, that the information about call session or call members is updated in real time. The updates are made automatically in response to Stream's WebSocket events arriving from the backend.

Learn more about setting up the boilerplate of joining a call room in our Joining and Creating Calls guide.

Video input preview
â€‹

The SDK comes with a pre-build VideoPreview component that handles video input stream preview. It also presents various UIs based on video playing state (starting, playing, unavailable video devices). In the example below, we are assembling a custom video preview using SDK's VideoPreview component and our custom UI components for each playing state.

import {
  useConnectedUser,
  DefaultVideoPlaceholder,
  StreamVideoParticipant,
  VideoPreview,
} from '@stream-io/video-react-sdk';

import { CameraIcon, LoadingIndicator } from '../icons';

export const Lobby = () => {
  return (
    <div>
      {/* ... other components */}
      <VideoPreview
        DisabledVideoPreview={DisabledVideoPreview}
        NoCameraPreview={NoCameraPreview}
        StartingCameraPreview={StartingCameraPreview}
      />
      {/* ... other components */}
    </div>
  );
};

export const DisabledVideoPreview = () => {
  const connectedUser = useConnectedUser();
  if (!connectedUser) return null;

  return (
    <DefaultVideoPlaceholder
      participant={
        {
          image: connectedUser.image,
          name: connectedUser.name,
        } as StreamVideoParticipant
      }
    />
  );
};

const NoCameraPreview = () => (
  <div>
    <CameraIcon />
  </div>
);

const StartingCameraPreview = () => (
  <div>
    <LoadingIndicator />
  </div>
);

Audio input preview
â€‹

Microphone configuration in the lobby may consist of checking, whether our microphone works and deciding, whether it will be enabled, when we join the call.

NOTE

Learn how to build a toggle button for call preview pages in Call controls tutorial.

NOTE

We build our custom sound detector in the dedicated tutorial about Audio Volume Indicator.

Device selection
â€‹

Switching devices is done through a set of utility methods or hooks. We speak a bit more about the function and the pre-built components in the media devices guide.

Device selector example

The selectors can be thought of as dropdowns in our example.

import { useCallStateHooks } from '@stream-io/video-react-sdk';

type DeviceSelectorProps = {
  devices: MediaDeviceInfo[];
  selectedDeviceId?: string;
  onSelect: (deviceId: string) => void;
};

export const DeviceSelector = ({
  devices,
  selectedDeviceId,
  onSelect,
}: DeviceSelectorProps) => {
  return (
    <div className="selector">
      {devices.map((device) => {
        const selected = selectedDeviceId === device.deviceId;
        return (
          <div
            key={device.deviceId}
            className={`option ${selected ? 'option--selected' : ''}`}
            onClick={() => onSelect(device.deviceId)}
          >
            {device.label}
          </div>
        );
      })}
    </div>
  );
};

export const AudioInputDeviceSelector = () => {
  const { useMicrophoneState } = useCallStateHooks();
  const { microphone, devices, selectedDevice } = useMicrophoneState();
  return (
    <DeviceSelector
      devices={devices || []}
      selectedDeviceId={selectedDevice}
      onSelect={(deviceId) => microphone.select(deviceId)}
    />
  );
};

export const VideoInputDeviceSelector = () => {
  const { useCameraState } = useCallStateHooks();
  const { camera, devices, selectedDevice } = useCameraState();
  return (
    <DeviceSelector
      devices={devices || []}
      selectedDeviceId={selectedDevice}
      onSelect={(deviceId) => camera.select(deviceId)}
    />
  );
};

export const AudioOutputDeviceSelector = () => {
  const { useSpeakerState } = useCallStateHooks();
  const { speaker, devices, selectedDevice, isDeviceSelectionSupported } =
    useSpeakerState();

  if (!isDeviceSelectionSupported) return null;
  return (
    <DeviceSelector
      devices={devices || []}
      selectedDeviceId={selectedDevice}
      onSelect={(deviceId) => speaker.select(deviceId)}
    />
  );
};

Participants in a call
â€‹

We can retrieve the list of members, that already joined the call (participants), by inspecting the call session object (session.participants). The object is provided and maintained up-to-date by useCallSession hook.

import { Avatar, useCallStateHooks } from '@stream-io/video-react-sdk';

export const ParticipantsPreview = () => {
  const { useCallSession } = useCallStateHooks();
  const session = useCallSession();

  if (session?.participants || session?.participants.length === 0) return null;

  return (
    <div>
      <div>Already in call ({session.participants.length}):</div>
      <div style={{ display: 'flex' }}>
        {session.participants.map((participant) => (
          <div>
            <Avatar
              name={participant.user.name}
              imageSrc={participant.user.image}
            />
            {participant.user.name && <div>{participant.user.name}</div>}
          </div>
        ))}
      </div>
    </div>
  );
};

Joining the call button
â€‹

Lastly, to join a call we simply invoke call.join(). Learn more about the topic in the dedicated Joining & Creating Calls guide.

Feedback
Previous
Ringing Call
Next
Video Placeholder
Did you find this page helpful?
Section:
Lobby Preview
SUBMIT
Prerequisites
The call data
Video input preview
Audio input preview
Device selection
Participants in a call
Joining the call button

Ringing Call

When building an application that relies on ring call workflow, you'll often want to build your own incoming or outgoing call panels. The React SDK already comes with a pre-built RingingCall component. However, in this article we will build a new one from scratch.

The component will render:

Call controls buttons to toggle audio and video enablement and accept resp. reject call buttons (the component will be called CallControls)
Avatars of called users or the current user's video preview (the component will be called CallMembers)
Call calling state indicator (the component will be called CallCallingStateLabel)
Feedback
Project setup and prerequisites
â€‹

Make sure you have the following prerequisites checked:

Registered Stream account
Have an app created in the Stream's dashboard to obtain app API key and secret.
Initiate the project (you can follow our introductory tutorial setup guide)
Have installed the Stream video and chat SDKs in the project:
npm install @stream-io/video-react-sdk

yarn add @stream-io/video-react-sdk

Feedback
App boilerplate
â€‹

In order we can start performing calls we need a StreamVideoClient instance connected to the Stream's server network with app credentials. For more information on how to do that, please take a look at our authentication guide.

Feedback
Ringing call panel implementation
â€‹

The component will rely on data accessed via our helper hooks:

useCall
useCallCallingState
useCallCreatedBy
useCallMembers
User preview
â€‹

The panel will render VideoPreview so that the user can see the camera input or avatars if video preview is disabled. The avatar display logic is as follows:

show all the called users' avatars if the call is outgoing (who am I calling)
show the avatar of the person who initiated the call in case of an incoming call (who is calling me)
import {
  useCall,
  useCallStateHooks,
  VideoPreview,
  UserResponse,
} from '@stream-io/video-react-sdk';

import { CallCallingStateLabel } from './CallCallingStateLabel';
import { CallControls } from './CallControls';
import { CallMembers } from './CallMembers';
import { useEffect } from 'react';

type RingingCallProps = {
  showMemberCount?: number;
};

export const CustomRingingCall = ({
  showMemberCount = 3,
}: RingingCallProps) => {
  const call = useCall();
  const { useCallMembers, useCallCreatedBy, useCameraState } =
    useCallStateHooks();

  const members = useCallMembers();
  const creator = useCallCreatedBy();

  const { camera, isMute: isCameraMute } = useCameraState();
  useEffect(() => {
    // enable the camera by default for all ring calls
    camera.enable();
  }, [camera]);

  if (!call) return null;

  const caller = creator;
  // show the caller if this is an incoming call or show all the users I am calling to
  let membersToShow: UserResponse[] = [];
  if (call.isCreatedByMe) {
    membersToShow =
      members
        ?.slice(0, showMemberCount)
        .map(({ user }) => user)
        .filter((u) => !!u) || [];
  } else if (caller) {
    membersToShow = [caller];
  }

  return (
    <div>
      {isCameraMute ? (
        <CallMembers members={membersToShow} />
      ) : (
        <VideoPreview />
      )}
      <CallCallingStateLabel />
      <CallControls />
    </div>
  );
};

Incoming call panel
â€‹

In the snippet below, the CallPanel component is expected to render our CustomRingingCall.

import {
  CallingState,
  StreamCall,
  useCall,
  useCallStateHooks,
  useCalls,
} from '@stream-io/video-react-sdk';

import { CustomActiveCallPanel } from './CustomActiveCallPanel';
import { CustomRingingCall } from './CustomRingingCall';

export const Video = () => {
  const calls = useCalls();
  return (
    <>
      {calls.map((call) => (
        <StreamCall call={call} key={call.cid}>
          <CallPanel />
        </StreamCall>
      ))}
    </>
  );
};

// custom component that renders ringing as well as active call UI
const CallPanel = () => {
  const call = useCall();
  const { useCallCallingState } = useCallStateHooks();
  const callingState = useCallCallingState();

  if (!call) return null;

  if (callingState === CallingState.JOINED) {
    return <CustomActiveCallPanel />;
  } else if (
    [CallingState.RINGING, CallingState.JOINING].includes(callingState)
  ) {
    return <CustomRingingCall />;
  }

  return null;
};

User avatars
â€‹

We display relevant users' avatars with CallMembers component.

import { Avatar } from '@stream-io/video-react-sdk';

import type { UserResponse } from '@stream-io/video-react-sdk';

type CallMembersProps = {
  members: UserResponse[];
};
const CallMembers = ({ members }: CallMembersProps) => {
  return (
    <div>
      {members.map((member) => (
        <div key={member.id}>
          <Avatar name={member.name} imageSrc={member.image} />
          {member.name && (
            <div>
              <span>{member.name}</span>
            </div>
          )}
        </div>
      ))}
    </div>
  );
};

Call calling state label
â€‹

To show to our users the state of call connection, we implement CallCallingStateLabel. The calling state is provided by useCallCallingState hook:

NOTE

In this component we are using translation service that comes bundled with the SDK. The service API is consumed with useI18n hook. Learn more about using the i18n service in the dedicated documentation.

import {
  CallingState,
  useCallStateHooks,
  useI18n,
} from '@stream-io/video-react-sdk';

const CALLING_STATE_TO_LABEL: Record<CallingState, string> = {
  [CallingState.JOINING]: 'Joining',
  [CallingState.RINGING]: 'Ringing',
  [CallingState.RECONNECTING]: 'Re-connecting',
  [CallingState.RECONNECTING_FAILED]: 'Failed',
  [CallingState.OFFLINE]: 'No internet connection',
  [CallingState.IDLE]: '',
  [CallingState.UNKNOWN]: '',
  [CallingState.JOINED]: 'Joined',
  [CallingState.LEFT]: 'Left call',
};

const CallCallingStateLabel = () => {
  const { t } = useI18n();
  const { useCallCallingState } = useCallStateHooks();
  const callingState = useCallCallingState();
  const callingStateLabel = CALLING_STATE_TO_LABEL[callingState];

  return callingStateLabel ? <div>{t(callingStateLabel)}</div> : null;
};

Call controls
â€‹

Finally, we build the call control buttons. We include buttons to toggle camera and microphone and buttons to accept and reject the call.

import {
  AcceptCallButton,
  CallingState,
  CancelCallButton,
  IconButton,
  useCall,
  useCallStateHooks,
} from '@stream-io/video-react-sdk';

const CallControls = () => {
  const call = useCall();
  const { useCallCallingState } = useCallStateHooks();
  const callingState = useCallCallingState();

  if (!call) return null;
  // show ringing call panel components only before the call is joined
  if (![CallingState.RINGING, CallingState.JOINING].includes(callingState))
    return null;

  // prevent users from rejecting call when already accepted
  const buttonsDisabled = callingState === CallingState.JOINING;

  return (
    <div>
      <ToggleAudioButton />
      <ToggleVideoButton />
      {call.isCreatedByMe ? (
        <CancelCallButton call={call} disabled={buttonsDisabled} />
      ) : (
        <>
          <AcceptCallButton call={call} disabled={buttonsDisabled} />
          <CancelCallButton
            onClick={() => call.leave({ reject: true })}
            disabled={buttonsDisabled}
          />
        </>
      )}
    </div>
  );
};

const ToggleAudioButton = () => {
  const { useMicrophoneState } = useCallStateHooks();
  const { microphone, isMute } = useMicrophoneState();
  return (
    <IconButton
      icon={isMute ? 'mic-off' : 'mic'}
      onClick={() => microphone.toggle()}
    />
  );
};

const ToggleVideoButton = () => {
  const { useCameraState } = useCallStateHooks();
  const { camera, isMute } = useCameraState();
  return (
    <IconButton
      icon={isMute ? 'camera-off' : 'camera'}
      onClick={() => camera.toggle()}
    />
  );
};

Feedback
Previous
Video Layout
Next
Lobby Preview
Did you find this page helpful?
Section:
Ringing Call
SUBMIT
Project setup and prerequisites
App boilerplate
Ringing call panel implementation
User preview
Call calling state label
Call controls

Video Layout

The purpose of this guide is to help developers understand how to build a custom call layout using Stream React Video SDK. The guide will cover the necessary steps:

connecting to Stream's edge infrastructure
joining a call
building the layout
Feedback
About the sample application
â€‹

To demonstrate the flexibility of our React Video SDK, we are going to build a custom layout that looks similar to Zoom's Speaker View layout. We will be using Vite + TS SPA template. The code for the app can be found here.

This application allows a user to join a call by providing the call ID and type. Once having joined a call, the user will be able to mute/unmute their audio and video and display the video streams of all participants in a "Zoom Speaker View"-like layout.

The final layout looks like this:

Feedback
Prerequisites
â€‹

Before we can join a call, we need to connect to Stream's edge infrastructure. To do that, we follow these steps:

Register for a Stream account and obtain our API key and secret.
Install the Stream React Video SDK:
npm install @stream-io/video-react-sdk
yarn add @stream-io/video-react-sdk
Initialize the SDK by passing in your API key, token and user information
Create and join a call
Feedback
Building and rendering the layout
â€‹

Now that we have successfully set up the React Video SDK and joined the call, we can start building our custom layout. For that purpose, we are going to utilize some fundamental React Video SDK components and hooks.

<ParticipantView /> - A component that renders a video stream of a participant.
useCall() - A hook that returns the current call instance. You can use this hook to access the call state and call methods.
useCallStateHooks() - A hook-alike function that wraps all call-state hooks. You can use this hook to access the list of all participants in the call, the local participant, and the dominant speaker.
useParticipants() - A hook that returns the list of all participants in the call.
// will load the default styling for the React Video SDK
import '@stream-io/video-styling/dist/css/styles.css';
import './SpeakerView.scss';

import {
  StreamTheme,
  ParticipantView,
  useCall,
  useCallStateHooks,
} from '@stream-io/video-react-sdk';

const { useParticipants } = useCallStateHooks();

export const SpeakerView = () => {
  const call = useCall();
  const { useParticipants } = useCallStateHooks();
  const [participantInSpotlight, ...otherParticipants] = useParticipants();

  return (
    // enables the default styling for the video SDK
    <div className="speaker-view">
      {call && otherParticipants.length > 0 && (
        <div className="participants-bar">
          {otherParticipants.map((participant) => (
            <div className="participant-tile" key={participant.sessionId}>
              <ParticipantView participant={participant} />
            </div>
          ))}
        </div>
      )}

      <div className="spotlight">
        {call && participantInSpotlight && (
          <ParticipantView
            participant={participantInSpotlight}
            trackType={
              hasScreenShare(participantInSpotlight)
                ? 'screenShareTrack'
                : 'videoTrack'
            }
          />
        )}
      </div>
    </div>
  );
};

// utility to determine whether the participant in spotlight is sharing their screen
const hasScreenShare = (p: StreamVideoParticipant) =>
  p.publishedTracks.includes(SfuModels.TrackType.SCREEN_SHARE);

Sorting the participants
â€‹

The React SDK comes with some default sorting logic for the participants in the call.

TIP

You can read more about this in the Sorting API.

The Participant Sorting API is customizable and allows us to define our custom sorting logic in case the default one doesn't fit your use case.

In this example, let's assume that we want to have a custom sorting logic for the participants in the call that would follow the following rules:

In 1:1 calls, the remote participant will be displayed in the largest space in the layout.
In group calls, we want this custom participant sorting:
Presenter will be displayed first
Dominant speaker will be displayed next
Pinned participants will be displayed after, as we want them to be pinned at the beginning of the participant list
The rest of the participants will be sorted at the top of the screen according to the following criteria:
Participants who are speaking or have their hand raised
Participants with audio and video will be displayed next
Followed by video-only participants
Followed by audio-only participants
Muted participants will be displayed last
Configure the sorting logic
â€‹

Having the rules set, let's go and configure the sorting function:

const getCustomSortingPreset = (
  isOneToOneCall: boolean = false,
): Comparator<StreamVideoParticipant> => {
  // 1:1 calls are a special case, where we want to always show the other
  // participant in the spotlight, and not show them in the participants bar.
  if (isOneToOneCall) {
    return (a: StreamVideoParticipant, b: StreamVideoParticipant) => {
      if (a.isLocalParticipant) return 1;
      if (b.isLocalParticipant) return -1;
      return 0;
    };
  }

  // a comparator decorator which applies the decorated comparator only if the
  // participant is invisible.
  // This ensures stable sorting when all participants are visible.
  const ifInvisibleBy = conditional(
    (a: StreamVideoParticipant, b: StreamVideoParticipant) =>
      a.viewportVisibilityState === VisibilityState.INVISIBLE ||
      b.viewportVisibilityState === VisibilityState.INVISIBLE,
  );

  // the custom sorting preset
  return combineComparators(
    screenSharing,
    dominantSpeaker,
    pinned,
    ifInvisibleBy(speaking),
    ifInvisibleBy(reactionType('raised-hand')),
    ifInvisibleBy(publishingVideo),
    ifInvisibleBy(publishingAudio),
  );
};

Apply sorting to the call
â€‹

Now that we have the sorting function, let's go ahead and apply it to the call. We can do that by calling the call.setSortParticipantsBy() method in a useEffect hook (see full code here):

export const SpeakerView = () => {
  const call = useCall();
  const { useParticipants } = useCallStateHooks();
  const [participantInSpotlight, ...otherParticipants] = useParticipants();


  // determine whether the call is a 1:1 call

  const isOneToOneCall = otherParticipants.length === 1;

  useEffect(() => {

    if (!call) return;

    const customSortingPreset = getCustomSortingPreset(isOneToOneCall);

    call.setSortParticipantsBy(customSortingPreset);

  }, [call, isOneToOneCall]);


  return (
    <div className="speaker-view">
      {call && otherParticipants.length > 0 && (
        <div className="participants-bar">
          {otherParticipants.map((participant) => (
            <div className="participant-tile" key={participant.sessionId}>
              <ParticipantView participant={participant} />
            </div>
          ))}
        </div>
      )}

      <div className="spotlight">
        {call && participantInSpotlight && (
          <ParticipantView
            participant={participantInSpotlight}
            trackType={
              hasScreenShare(participantInSpotlight)
                ? 'screenShareTrack'
                : 'videoTrack'
            }
          />
        )}
      </div>
    </div>
  );
};

// utility to determine whether the participant in spotlight is sharing their screen
const hasScreenShare = (p: StreamVideoParticipant) =>
  p.publishedTracks.includes(SfuModels.TrackType.SCREEN_SHARE);

// the sorting code goes here

Bandwidth and CPU optimization
â€‹

In calls with a large number of participants, your horizontal list will grow past viewable boundaries. Each of these ParticipantView components will keep subscribing to the video stream and will keep playing it even if they're not visible to the user which is wasteful because of heavy CPU and bandwidth usage. To mitigate this issue each Call instance utilizes one ViewportTracker instance (call.dynascaleManager.viewportTracker) with observe and setViewport methods. The ParticipantView component already utilizes this functionality under the hood (observe) so all we need to do is to call setViewport with your horizontal list element as an argument and we're set.

export const SpeakerView = () => {
  const call = useCall();
  const { useParticipants } = useCallStateHooks();
  const [participantInSpotlight, ...otherParticipants] = useParticipants();

  const [participantsBar, setParticipantsBar] = useState<HTMLDivElement | null>(

    null,

  );


  // determine whether the call is a 1:1 call
  const isOneToOneCall = otherParticipants.length === 1;
  useEffect(() => {
    if (!call) return;
    const customSortingPreset = getCustomSortingPreset(isOneToOneCall);
    call.setSortParticipantsBy(customSortingPreset);
  }, [call, isOneToOneCall]);


  useEffect(() => {

    if (!participantsBar || !call) return;



    const cleanup = call.dynascaleManager.setViewport(participantsBar);



    return () => cleanup();

  }, [participantsBar, call]);


  return (
    <div className="speaker-view">
      {call && otherParticipants.length > 0 && (

        <div ref={setParticipantsBar} className="participants-bar">

          {otherParticipants.map((participant) => (
            <div className="participant-tile" key={participant.sessionId}>
              <ParticipantView participant={participant} />
            </div>
          ))}
        </div>
      )}

      <div className="spotlight">
        {call && participantInSpotlight && (
          <ParticipantView
            participant={participantInSpotlight}
            trackType={
              hasScreenShare(participantInSpotlight)
                ? 'screenShareTrack'
                : 'videoTrack'
            }
          />
        )}
      </div>
    </div>
  );
};

// utility to determine whether the participant in spotlight is sharing their screen
const hasScreenShare = (p?: StreamVideoParticipant) =>
  p?.publishedTracks.includes(SfuModels.TrackType.SCREEN_SHARE);


Now these changes will ensure that we only subscribe to the video streams users actually see on their screens.

Final steps
â€‹

Let's add one last component which is just a custom combination of call control buttons and finalize our application by composing the components we just created:

import {
  SpeakingWhileMutedNotification,
  ToggleAudioPublishingButton,
  ToggleVideoPublishingButton,
  CancelCallButton,
  ScreenShareButton,
  StreamTheme,
} from '@stream-io/video-react-sdk';

const CustomCallControls = () => {
  const call = useCall();

  return (
    <div className="str-video__call-controls">
      <ScreenShareButton />
      <SpeakingWhileMutedNotification>
        <ToggleAudioPublishingButton />
      </SpeakingWhileMutedNotification>
      <ToggleVideoPublishingButton />
      <CancelCallButton
        onLeave={() => {
          console.log('onLeave callback called');
        }}
      />
    </div>
  );
};

export const App = () => {
  return (
    // enables the default styling for the video SDK
    <StreamTheme>
      <SpeakerView />
      <CustomCallControls />
    </StreamTheme>
  );
};


And that's it. We have successfully built our custom layout. At last, you can find the running example of this guide here.

NOTE

The tutorial does not include the styling of the component, but you can find the full code in the SpeakerView.scss file.

Feedback
Further customization
â€‹

You can use our data model to build your own custom layouts. You can go further and build your own custom components, but we advise you to use some of our core components (e.g. ParticipantView) and hooks to make sure that you wouldn't have to re-implement some baked-in functionality like:

Simulcast,
DynaScale,
Track Subscription handling,
muting/unmuting, etc.

Thanks for following this guide and always feel free to reach out to us at the bottom of this page or let us know when you build up something cool with our SDK on Twitter.

Feedback
Previous
Participant Label
Next
Ringing Call
Did you find this page helpful?
Section:
Video Layout
SUBMIT
About the sample application
Prerequisites
Building and rendering the layout
Sorting the participants
Configure the sorting logic
Apply sorting to the call
Bandwidth and CPU optimization
Final steps
Further customization

Participant Label

There may be a plethora of designs for label that is displayed above the participant video. The SDK's default label shows:

user's name
microphone and camera mute state
dominant speaker label
connection quality indicator
Default muted participant label
Default un-muted participant label speaking

It is expected that the default component may not meet all the requirements of all the apps in the world. Therefore, we will look into ways, how to customize the contents of the participant label in this tutorial.

Feedback
Custom participant label
â€‹

Our custom label will include a human-readable call join time in addition to what the design requirements were. To achieve this, we will need to override the whole participantParticipantViewUI component. You can learn more about ParticipantViewUI customizations in the participant view customizations guide.

To retrieve the data about the participant, whose view we are about to render, we use useParticipantViewContext context consumer hook.

import { useParticipantViewContext } from '@stream-io/video-react-sdk';

import { getHumanReadableTimeElapsed } from '../utils';

const ParticipantDetails = () => {
  const { participant } = useParticipantViewContext();

  const readableTimeSinceJoined = getHumanReadableTimeElapsed(
    participant.joinedAt,
  );

  return (
    <div title={participant.name}>
      <span>{participant.name}</span>
      <span>{readableTimeSinceJoined}</span>
    </div>
  );
};

export const CustomParticipantViewUI = () => {
  return (
    <>
      <ParticipantDetails />
      {/* your other custom UI elements */}
    </>
  );
};

Feedback
Final steps
â€‹

Now we can pass this custom ParticipantViewUI component down to our call layout components or directly to ParticipantView component in our custom call layout as described in the aforementioned ParticipantView customizations guide.

import { useCallStateHooks } from '@stream-io/video-react-sdk';

import { CustomParticipantViewUI } from '../ParticipantViewUI';
import { CustomVideoPlaceholder } from '../VideoPlaceholder';

export const CustomCallLayout = () => {
  const { useParticipants } = useCallStateHooks();
  const participants = useParticipants();

  return (
    <div>
      {/* your other custom UI elements */}
      {participants.map((participant) => (
        <div key={participant.sessionId}>
          <ParticipantView
            participant={participant}

            ParticipantViewUI={CustomParticipantViewUI}

            VideoPlaceholder={CustomVideoPlaceholder}
          />
        </div>
      ))}
    </div>
  );
};

Feedback
Previous
Call Controls
Next
Video Layout
Did you find this page helpful?
Section:
Participant Label
SUBMIT
Custom participant label
Final steps

Call Controls

Developers building apps in browsers have to face the dilemma of adapting their layouts to high and small resolutions. In the desktop environment there is a more generous amount of space than on mobile devices. Many times, there may not be one component that would fit all the constraints. Therefore, the React SDK provides the flexibility in assembling the call controls layout. We can pick any combination of buttons bundled with the SDK. Each button controls its own area of responsibility. Our task, as integrators is to create a component that puts these buttons together as we wish. In this example we intend to show, how to do just that.

NOTE

The React SDK exports a pre-built component CallControls. If it does not meet all the requirements, we encourage everybody to assemble their own CallControls component.

Feedback
Assembling own CallControls component
â€‹

Currently, the SDK exports the following call controls components:

AcceptCallButton
CancelCallButton
ToggleAudioPreviewButton
ToggleAudioPublishingButton
ToggleAudioOutputButton
ToggleVideoPreviewButton
ToggleVideoPublishingButton
ScreenShareButton
RecordCallButton

The default CallControls implementation makes use of some of these buttons only. All the buttons access the call related data with hooks instead of props. Therefore, the custom CallControls component just renders selected button components and orders them in any order that meets the customisation requirements. An example follows:

import {
  CancelCallButton,
  SpeakingWhileMutedNotification,
  ToggleAudioPublishingButton,
  ToggleVideoPublishingButton,
} from '@stream-io/video-react-sdk';

import type { CallControlsProps } from '@stream-io/video-react-sdk';

export const CallControls = ({ onLeave }: CallControlsProps) => (
  <div className="str-video__call-controls">
    <SpeakingWhileMutedNotification>
      <ToggleAudioPublishingButton />
    </SpeakingWhileMutedNotification>
    <ToggleVideoPublishingButton />
    <CancelCallButton onLeave={onLeave} />
  </div>
);

Feedback
Building custom control buttons
â€‹

It may as well be the case, that the default call controls buttons look does not meet our design requirements. It is very easy to build custom buttons making use of the hooks provided by the SDK. In the next few sections, we will demonstrate how custom call controls buttons can be built.

NOTE

Implementing call controls buttons will often be in reality associated with handling permissions to perform the given action. To learn about permission handling, take a look at our permissions and moderation guide.

Button to accept a call
â€‹

We will need a call accept button when building app that makes use of ring call workflow. To accept a call we just invoke call.join(). So the minimal call accept button could look like this:

import { useCall } from '@stream-io/video-react-sdk';

export const CustomAcceptCallButton = () => {
  const call = useCall();
  return (
    <button onClick={() => call?.join()}>
      <span className="my-icon" />
    </button>
  );
};

Button to cancel a call
â€‹

To cancel an outgoing call in ring call scenario or to leave an already joined call, we just invoke call.leave(). To reject a call in ring call scenario, invoke call.leave({reject: true}).

import { useCall } from '@stream-io/video-react-sdk';

type CustomCancelCallButtonProps = {
  reject?: boolean;
};

export const CustomCancelCallButton = ({
  reject,
}: CustomCancelCallButtonProps) => {
  const call = useCall();
  return (
    <button onClick={() => call?.leave({ reject })}>
      <span className="my-icon" />
    </button>
  );
};

Toggling audio
â€‹

Toggling microphone in an active call turns around publishing audio input streams and enabling the audio state. The bare-bones button to toggle audio in an active call could look like the following:

import { useCallStateHooks } from '@stream-io/video-react-sdk';

export const CustomToggleAudioPublishingButton = () => {
  const { useMicrophoneState } = useCallStateHooks();
  const { microphone, isMute } = useMicrophoneState();
  return (
    <button onClick={() => microphone.toggle()}>
      {isMute ? (
        <span className="my-icon-disabled" />
      ) : (
        <span className="my-icon-enabled" />
      )}
    </button>
  );
};


To toggle audio before joining a call (for example in a call lobby or on pending call panel), we can use the same API. The state is kept on a call level, so if in the preview the audio was disabled, then it will remain disabled after joining the call.

Toggling video
â€‹

To toggle video input, the approach is analogous to that of audio input.

import { useCallStateHooks } from '@stream-io/video-react-sdk';

export const CustomToggleVideoPublishingButton = () => {
  const { useCameraState } = useCallStateHooks();
  const { camera, isMute } = useCameraState();
  return (
    <button onClick={() => camera.toggle()}>
      {isMute ? (
        <span className="my-icon-disabled" />
      ) : (
        <span className="my-icon-enabled" />
      )}
    </button>
  );
};


To toggle video before joining a call (for example in a call lobby or on pending call panel), we can use the same API. The state is kept on a call level, so if in the preview the video was disabled, then it will remain disabled after joining the call.

Toggling screen sharing
â€‹

To toggle Screen Sharing, you can utilize the following API:

import { useCallStateHooks } from '@stream-io/video-react-sdk';

export const CustomScreenShareButton = () => {
  const { useScreenShareState, useHasOngoingScreenShare } = useCallStateHooks();
  const { screenShare, isMute: isScreenSharing } = useScreenShareState();

  // determine, whether somebody else is sharing their screen
  const isSomeoneScreenSharing = useHasOngoingScreenShare();
  return (
    <button
      // disable the button in case I'm not the one sharing the screen
      disabled={!isScreenSharing && isSomeoneScreenSharing}
      onClick={() => screenShare.toggle()}
    >
      {isScreenSharing ? (
        <span className="my-icon-enabled" />
      ) : (
        <span className="my-icon-disabled" />
      )}
    </button>
  );
};

Recording calls
â€‹

To start recording a call, we invoke call.startRecording() and to stop it call.stopRecording(). To determine, whether the recording already began, use the hook useIsCallRecordingInProgress().

import { useCallback, useEffect, useState } from 'react';
import {
  LoadingIndicator,
  useCall,
  useCallStateHooks,
} from '@stream-io/video-react-sdk';

export const CustomRecordCallButton = () => {
  const call = useCall();
  const { useIsCallRecordingInProgress } = useCallStateHooks();

  const isCallRecordingInProgress = useIsCallRecordingInProgress();
  const [isAwaitingResponse, setIsAwaitingResponse] = useState(false);

  useEffect(() => {
    // we wait until call.recording_started/stopped event to flips the
    // `isCallRecordingInProgress` state variable.
    // Once the flip happens, we remove the loading indicator
    setIsAwaitingResponse((isAwaiting) => {
      if (isAwaiting) return false;
      return isAwaiting;
    });
  }, [isCallRecordingInProgress]);

  const toggleRecording = useCallback(async () => {
    try {
      setIsAwaitingResponse(true);
      if (isCallRecordingInProgress) {
        await call?.stopRecording();
      } else {
        await call?.startRecording();
      }
    } catch (e) {
      console.error(`Failed start recording`, e);
    }
  }, [call, isCallRecordingInProgress]);

  return (
    <>
      {isAwaitingResponse ? (
        <LoadingIndicator
          tooltip={
            isCallRecordingInProgress
              ? 'Waiting for recording to stop... '
              : 'Waiting for recording to start...'
          }
        />
      ) : (
        <button disabled={!call} title="Record call" onClick={toggleRecording}>
          {isCallRecordingInProgress ? (
            <span className="my-icon-enabled" />
          ) : (
            <span className="my-icon-disabled" />
          )}
        </button>
      )}
    </>
  );
};

Feedback
Previous
Overview
Next
Participant Label
Did you find this page helpful?
Section:
Call Controls
SUBMIT
Assembling own CallControls component
Building custom control buttons
Button to accept a call
Button to cancel a call
Toggling audio
Toggling video
Toggling screen sharing
Recording calls

Overview

Stream UI components are highly customizable and allow you to fully customize styles to your taste. This UI Cookbook will walk you through how to customize each component in your video call.

Video layout

Call controls

Participant view

Lobby preview

Ringing call

Video placeholder

Participant label

Permission requests

Audio volume indicator

Speaking while muted notifiaction

Connection quality indicator

Connection unstable

Feedback
Previous
Speaking while muted notification
Next
Call Controls
Did you find this page helpful?
Section:
Overview
SUBMIT

Theme

The React Video SDK ships with a default UI theme (CSS stylesheet) that you can include in your application. In this chapter, we'll go through the details on how you can utilize and customize the default theme.

Feedback
Usage
â€‹
Importing the CSS
â€‹

The SDK includes a CSS stylesheet that can be easily imported into your project to apply a pre-built theme to your video components. To use the CSS stylesheet, you can import it from the SDK's dist folder:

import '@stream-io/video-react-sdk/dist/css/style.css';
// ideally, Stream Video theme should be imported before your own styles
import './my-styles.css';

Using the StreamTheme component
â€‹

The <StreamTheme /> component is a utility component that renders an HTML element with the CSS class name of str-video attached to it. This CSS class enables our default theme to be applied to the children of the rendered element.

The <StreamTheme /> supports the as property, allowing you to render different HTML elements or custom components based on the value of the as prop. By default, the <StreamTheme /> component renders a <div> element, but you can pass any valid HTML element or custom React component to the as prop to render a different element.

In addition, you can also pass any other HTML attribute as a prop to the StreamTheme component, which will be applied to the rendered element.

import { StreamTheme, StreamVideo } from '@stream-io/video-react-sdk';

const App = () => {
  return (
    <StreamVideo client={client}>
      <StreamTheme as="main" className="my-custom-root-class">
        <MyAppUI />
      </StreamTheme>
    </StreamVideo>
  );
};

Feedback
Customization
â€‹
Theme variables
â€‹

You can customize the colors, border-radius settings, and icons used by the built-in UI components.

Customizing can be done using CSS variables defined in our variables file.

Use the .str-video selector to override theme variables.

import '@stream-io/video-react-sdk/dist/css/style.css';

// Use your own font
html {
  font-family: sans-serif;
}

.str-video {
  --str-video__primary-color: #6002ee;
  --str-video__secondary-color: #90ee02;
  --str-video__text-color1: #282b2b;
  --str-video__border-radius-circle: 15px;
  --str-video__icon--download: url('base64 encoded SVG')
}

Light and dark themes
â€‹

The React Video SDK comes with a single predefined theme. However, you can configure more themes, for example, to support light and dark modes.

You can use the className prop of the StreamTheme to provide the selected theme:

import { StreamTheme, StreamVideo } from '@stream-io/video-react-sdk';
import { useState } from 'react';

const App = () => {
  const [theme, setTheme] = useState<'dark' | 'light'>('dark');

  return (
    <StreamVideo client={client}>
      <button onClick={() => setTheme('dark')}>Dark theme</button>
      <button onClick={() => setTheme('light')}>Light theme</button>
      <StreamTheme className={theme}>
        <MyAppUI />
      </StreamTheme>
    </StreamVideo>
  );
};


Provide the configuration for the different themes:

import '@stream-io/video-react-sdk/dist/css/style.css';

.str-video.dark {
  --str-video__primary-color: #00796b;
  --str-video__secondary-color: #cddc39;
  // other colors
}

.str-video.light {
  --str-video__primary-color: #009688;
  --str-video__secondary-color: #dce775;
   // other colors
}

Custom CSS code
â€‹

If you want to tweak the design/layout of a built-in component, it's often easier to write a few lines of CSS code than to create your own custom component.

However, please note that the HTML/CSS structure of the UI components can change with any new release (even with patch releases), so you should test if your custom CSS codes are still working with each SDK update.

CSS cascade layers make it easier to override the default styles of the SDK, here is an example:

@import url('@stream-io/video-react-sdk/dist/css/styles.css') layer(video-default);

.str-video__call-controls__button {
  padding: 20px;
}

Feedback
Previous
Overview
Next
Call layout
Did you find this page helpful?
Section:
Theme
SUBMIT
Usage
Importing the CSS
Using the StreamTheme component
Customization
Theme variables
Light and dark themes
Custom CSS code

Overview

There are different ways to use the React Video SDK to build out UI. It comes with powerful built-in components ready for use. In addition, it allows for styling and custom theming options with custom CSS.

For custom use cases it is also possible to create your own components to fully tailor the SDK to your needs.

NOTE

Please note that we suggest not to override a few, core components as those contain complex, low-level logic related to performance, the list of these components can be found in the UI Components/Core section.

This page guides you through all the options you have with increasing levels of customization.

Feedback
Using pre-built components
â€‹

You can create a fully functioning video calling application with just a few lines of code using pre-built components:

import '@stream-io/video-react-sdk/dist/css/styles.css';
import {
  CallControls,
  StreamCall,
  StreamTheme,
  StreamVideo,
  SpeakerLayout,
} from '@stream-io/video-react-sdk';

const MyApp = () => {
  // Assuming you have the 'client' and 'call' instance created
  return (
    <StreamVideo client={client}>
      <StreamTheme>
        <StreamCall call={call}>
          <SpeakerLayout />
          <CallControls />
        </StreamCall>
      </StreamTheme>
    </StreamVideo>
  );
};

Feedback
Theming with CSS
â€‹

If you only want to customize the styling of the available components, there is a wide range of CSS variables that you can override. With that, you can achieve a significant amount of theming in your video product.

To change them you can simply override them with your custom values.

Here is an example:

.str-video {
  // The primary color that is used
  --str-video__primary-color: green;
}


Check out the theming guide for more details.

Feedback
Custom components
â€‹

You can create custom components from scratch or you can use built-in components as building blocks.

The Call & Participant State guide describes how you can access state variables in your custom components.

Here is an example of how you can use the useParticipants() hook to get all call participants and render them in your application.

import { useCallStateHooks } from '@stream-io/video-react-sdk';

const MyParticipantList = () => {
  const { useParticipants } = useCallStateHooks();
  const participants = useParticipants();
  return (
    <>
      <h2>Participants</h2>
      {participants.map((participant) => (
        <div key={participant.sessionId}>
          <img
            src={participant.image}
            alt={`Profile picture of ${participant.name}.`}
          />
          <span>{participant.name}</span>
        </div>
      ))}
    </>
  );
};

SUCCESS

The UI Cookbook section contains tutorials that cover common customization examples.

Combining all of the possibilities that you have gives you the freedom to use the performant pre-built components when they suit your needs. At the same time if you have more customized use cases you can fully tailor the appearance to your needs.

Feedback
Previous
Call Preview and Thumbnail
Next
Theme
Did you find this page helpful?
Section:
Overview
SUBMIT
Using pre-built components
Theming with CSS
Custom components

Call Preview and Thumbnail

Depending on your call type settings, our system can occasionally generate a preview image (thumbnail) for your call. You can use this image to show a preview of the call in your app, typically in a lobby, waiting room, etc.

Feedback
Get the preview thumbnail
â€‹
import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useCallThumbnail } = useCallStateHooks();
const thumbnail = useCallThumbnail();

console.log(thumbnail.image_url);

Feedback
Show the preview thumbnail
â€‹

Our React Video SDK provides a built-in component to show the preview image. You can use it like this:

import { CallPreview } from '@stream-io/video-react-sdk';

export const MyComponent = () => {
  return (
    <div className="my-container">
      <CallPreview
        className="my-call-preview-class"
        style={{ width: '240px', height: '135px' }}
      />
    </div>
  );
};


Optionally, it accepts className and style props, so you can style it as you wish.

Feedback
Previous
Participant Sorting
Next
Overview
Did you find this page helpful?
Section:
Call Preview and Thumbnail
SUBMIT
Get the preview thumbnail
Show the preview thumbnail

Participant Sorting

The Participant Sorting API is a powerful tool built on top of the internal Comparator<T> API, providing developers with the ability to sort participants in various scenarios. This API offers common comparators and built-in presets that can be easily customized or used out-of-the-box, making participant sorting a seamless experience.

When dealing with real-time communication applications, it is often necessary to sort participants based on specific criteria. Whether you need to adjust the sorting in existing view layouts or define new sorting presets, the Participant Sorting API is here to simplify the process.

By utilizing the Comparator<T> API and the provided built-in comparators and presets, developers can effortlessly sort participants according to their requirements.

Feedback
Comparator<T>
API overview
â€‹

The Comparator<T> API is the foundation upon which the Participant Sorting API is built. It defines a function type Comparator<T> that takes two arguments a and b of type T and returns -1, 0, or 1 based on the comparison between the two items. This API allows developers to create custom comparators tailored to their specific needs.

Ultimately, this API can be used in conjunction with the Array.sort method to sort any type of data.

import {
  Comparator,
  combineComparators,
  conditional,
  descending,
} from '@stream-io/video-react-sdk';

type Participant = {
  id: number;
  name: string;
};

// comparator that sorts by name in ascending order
const byName: Comparator<Participant> = (a, b) => {
  if (a.name < b.name) return -1;
  if (a.name > b.name) return 1;
  return 0;
};

// comparator that sorts by id in ascending order
const byId: Comparator<Participant> = (a, b) => {
  if (a.id < b.id) return -1;
  if (a.id > b.id) return 1;
  return 0;
};

// comparator that sorts by age in ascending order
const byAge: Comparator<Participant> = (a, b) => {
  if (a.age < b.age) return -1;
  if (a.age > b.age) return 1;
  return 0;
};

// creates a new comparator that sorts by name in descending order
const byNameDescending: Comparator<Participant> = descending(byName);

// `conditional` creates a new comparator that applies the provided comparator only
// if the provided predicate returns `true`. The `predicate` itself, takes the two arguments
// and returns a boolean value.
const byAgeIfEnabled: Comparator<Participant> = conditional(
  (a, b) => opts.isSortByAgeEnabled,
)(descending(byAge));

// combineComparator creates a new Comparator<T> that combines the provided comparators in one.
// this comparator will sort by name in descending order, by age if enabled,
// and then by id in ascending order
const sortingCriteria = combineComparators(
  byNameDescending,
  byAgeIfEnabled,
  byId,
);

// participants array
const sorted = [p1, p2, p3].sort(sortingCriteria);

SUCCESS

The Comparator<T> API is quite generic and can be used to sort any type of data. Works great in pair with browser's Array.sort API.

Feedback
Built-in common comparators
â€‹

The Participant Sorting API provides a set of common comparators that cover common sorting scenarios. These comparators are specifically designed for participant sorting and offer convenience when defining sorting criteria.

The built-in common comparators include:

dominantSpeaker: Sorts participants based on their dominance in the call.
speaking: Sorts participants based on whether they are currently speaking.
screenSharing: Sorts participants based on whether they are currently screen sharing.
publishingVideo: Sorts participants based on whether they are currently publishing video.
publishingAudio: Sorts participants based on whether they are currently publishing audio.
pinned: Sorts participants based on whether they are pinned in the user interface.
reactionType(type): Sorts participants based on the type of reaction they have.
role(...roles): Sorts participants based on their assigned role.
name: Sorts participants based on their names.

All of these comparators are available in the @stream-io/video-react-sdk package and can be imported as follows:

import {
  dominantSpeaker,
  speaking,
  screenSharing,
  publishingVideo,
  publishingAudio,
  pinned,
  reactionType,
  role,
  name,
} from '@stream-io/video-react-sdk';

// ...


These built-in comparators serve as a starting point for sorting participants and can be used individually or combined to create more complex sorting criteria.

Feedback
Sorting customization on the call level
â€‹

The Participant Sorting API allows dynamic sorting customization during runtime. Developers can utilize the call.setSortParticipantsBy(comparator) API to change the sorting criteria based on user interactions or application logic. This flexibility empowers developers to provide sorting controls within their application, giving users the ability to customize participant sorting according to their preferences.

Lets take a look at an example:

import {
  useCall,
  combineComparators,
  dominantSpeaker,
  publishingVideo,
  publishingAudio,
  screensharing,
  speaking,
  reactionType,
  pinnned,
} from '@stream-io/video-react-sdk';

// ... boilerplate code

// we take the existing call instance
const call = useCall();

// we create a new comparator that combines the built-in comparators
// and sorts participants by the following criteria:
const comparator = combineComparators(
  pinned, // 1. pinned participants first
  screenSharing, // 2. participants who are screensharing
  dominantSpeaker, // 3. dominant speaker
  reactionType('raised-hand'), // 4. participants with raised hand
  speaking, // 5. participants currently speaking
  publishingVideo, // 6. participants publishing video
  publishingAudio, // 7. participants publishing audio
  // 8. everyone else
);

// will apply the new sorting criteria immediately
call.setSortParticipantsBy(comparator);

NOTE

In some scenarios, we might want to have special sorting criteria for a specific component in our app. For example, in the participant list component, we might want to sort participants by name.

For this purpose, we have extended the built-in useParticipants hook with a sortBy: Comparator<StreamVideoParticipant> option parameter.

import {
  useCallStateHooks,
  combineComparators,
  name,
} from '@stream-io/video-react-sdk';

const { useParticipants } = useCallStateHooks();

// this will override the call's default sorting criteria
// and will return a list of participants sorted by name
const participants = useParticipants({ sortBy: name });

// you can also provide your custom comparator
const myComparator = combineComparators(/* ... */);
const participants = useParticipants({ sortBy: myComparator });

CAUTION

When using custom comparator in combination with the useParticipants hook, please make sure to provide a stable reference to the comparator. Otherwise, you might end up with unexpected behavior (unexpected re-renders, etc.).

Our proposal is to use stateless comparators defined outside of the component's scope. In case you need to use a stateful comparator, please make sure to memoize it using React.useMemo or React.useCallback hooks.

// stateless comparator
const myStatelessComparator = combineComparators(/* ... */);

export const MyComponent = () => {
  const { useParticipants } = useCallStateHooks();

  // component scope
  const participants1 = useParticipants({ sortBy: myStatelessComparator });

  // memoized comparator
  const myStatefulComparator = React.useMemo(
    () => combineComparators(/* ... */),
    [dependency1, dependency2],
  );
  const participants2 = useParticipants({ sortBy: myStatefulComparator });

  // ...
};

Feedback
Built-in sorting presets
â€‹

To further simplify participant sorting, the Participant Sorting API offers built-in presets. These presets are pre-configured sorting criteria linked to specific call types, reducing the effort required to define sorting rules.

The following presets are available:

defaultSortPreset: The default sorting preset applicable to general call scenarios.
speakerLayoutSortPreset: A preset specifically designed for the 'default' call type, optimizing participant sorting for speaker layout view.
livestreamOrAudioRoomSortPreset: A preset tailored for the 'livestream' and 'audio_room' call types, ensuring optimal participant sorting in livestream or audio room scenarios.

These presets are directly applied to the call's sorting mechanism. For custom call types, unless specified otherwise, our SDK would use the defaultSortPreset preset.

All of these presets are available in the @stream-io/video-react-sdk package and can be imported as follows:

import {
  defaultSortPreset,
  speakerLayoutSortPreset,
  livestreamOrAudioRoomSortPreset,
} from '@stream-io/video-react-sdk';

SUCCESS

For your custom call types, you can define your participant sorting presets and register them generally in the SDK.

Check the next section to learn how.

Feedback
Sorting customization on the call type
â€‹

Sometimes, you want to keep your UI components free from sorting logic and instead, define sorting criteria per call type. To do so, you can register your sorting presets for your custom call types or override the existing ones by using our SDK's CallTypes registry.

import { combineComparators, CallTypes, CallType } from '@stream-io/video-react-sdk';

// setup your custom sorting preset
const myCustomSortPreset = combineComparators(/* ... */);

// update existing type
CallTypes.get('default').options.sortParticipantsBy = myCustomSortPreset;

// register new type
CallTypes.register(new CallType('my-custom-type', {
  options: {
    sortParticipantsBy: myCustomSortPreset,
  },
});

Feedback
Disabling participant sorting
â€‹

In some cases, you may want to disable participant sorting altogether. This can be achieved by setting our special noopComparator as the sorting criteria of the Call or the CallType.

import { noopComparator, useCall } from '@stream-io/video-react-sdk';

const call = useCall();
call.setSortParticipantsBy(noopComparator());

Feedback
Previous
Reactions & Custom Events
Next
Call Preview and Thumbnail
Did you find this page helpful?
Section:
Participant Sorting
SUBMIT
Comparator<T> API overview
Built-in common comparators
Sorting customization on the call level
Built-in sorting presets
Sorting customization on the call type
Disabling participant sorting

Reactions & Custom Events

Reactions allow call participants to send emojis in real-time.

Custom events let participants send and receive arbitrary WebSocket messages. For example, if you want to implement a drawing feature in your call, you can use custom events for synchronizing the drawing board between participants.

Feedback
Reactions
â€‹
SUCCESS

The ReactionsButton and Reaction components support reactions out-of-the-box, but for advanced use-cases you can also build your own reaction system.

Sending reactions
â€‹

You can send a reaction using the sendReaction method of a Call instance.

const call: Call;

await call.sendReaction({ type: 'raised-hand' });


The value of the type attribute can be any string.

It's also possible to provide additional data for the reaction:

const call: Call;

await call.sendReaction({
  type: 'raised-hand',
  emoji_code: ':raise-hand:',
  custom: { clearAfterTimeout: true },
});


The emoji_code attribute is used by the SDK components to decide which emoji to display on the UI.

The custom property can contain any data.

Receiving reactions
â€‹

Reactions are only delivered to clients that are watching the call.

The participant state will contain the latest reaction of each participant:

const { useParticipants } = useCallStateHooks();
const participants = useParticipants();

const reactions = participants.map((p) => p.reaction);


You can also subscribe to the call.reaction_new WebSocket event to receive reactions. For more information, check out our Events guide.

Clearing reactions
â€‹

If you're using the participant state for receiving reactions, you can also clear the latest reaction using the resetReaction method:

const call: Call;
const { useParticipants } = useCallStateHooks();
const participants = useParticipants();

call.resetReaction(participants[0].sessionId);


This is a local action, it won't send any WebSocket messages. It's helpful if you only want to display reactions for a set period of time.

Feedback
Custom events
â€‹
Sending custom events
â€‹

You can use the sendCustomEvent method of the Call instance to send custom events:

const call: Call;

await call.sendCustomEvent({
  type: 'draw',
  x: 10,
  y: 30,
});


The custom property can contain any data.

Receiving custom events
â€‹

Custom events are only delivered to clients that are watching the call.

To receive custom events, you need to subscribe to the custom WebSocket event:

const call: Call;

call.on('custom', (event: StreamCallEvent) => {
  if (event.type === 'custom') {
    console.log(`Custom event: ${event.custom.type}`);
  }
});


For more information, check out our Events guide.

Feedback
Previous
Permissions & Moderation
Next
Participant Sorting
Did you find this page helpful?
Section:
Reactions & Custom Events
SUBMIT
Reactions
Sending reactions
Receiving reactions
Clearing reactions
Custom events
Sending custom events
Receiving custom events

Permissions & Moderation

In many types of calls, there is a requirement for providing different users with certain permissions and capabilities. A typical example is a webinar where the host wants to control who can speak or who can share their video or screen.

The Stream Video SDK provides a certain set of permissions and capabilities that can be used to control the behavior of participants in a call.

Feedback
Conceptual overview
â€‹
Roles
â€‹

The Stream Video API allows assigning roles to users. Each user has a global role, and they will also have a call-level role for each call they join. The Stream Video API provides a set of predefined roles, but it's also possible to create your own roles.

Call types
â€‹

Call types also allow for a more granular control system:

you can enable/disable certain features on a call type level
you can configure how each call-level role works on a call type level
Capabilities
â€‹

Based on a user's roles and the call type settings, we can determine which actions are allowed for a user joined to a specific call.

Feedback
Permissions
â€‹

As soon as you join a call, the Call instance would allow you to check the permissions of the local user or perform some permission-related actions:

Check permissions
â€‹
import { OwnCapability } from '@stream-io/video-react-sdk';

const call = client.call(type, id);
const canSendAudio = call.permissionsContext.hasPermission(
  OwnCapability.SEND_AUDIO,
);


In our React Video SDK, you can use the useHasPermissions hook to check for permissions.

import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useHasPermissions } = useCallStateHooks();
const canSendAudio = useHasPermissions(OwnCapability.SEND_AUDIO);

Request permissions
â€‹

Every user may request permission to perform certain actions depending on the call type and call settings. For example, in an audio-room call type, only the hosts have send-audio permission by default. Other users should request this permission before they can start sending audio if the call settings allow it.

import { OwnCapability } from '@stream-io/video-react-sdk';

const call = client.call(type, id);
if (!call.permissionsContext.canRequest(OwnCapability.SEND_AUDIO)) {
  console.log('The host has disabled the ability to request this permission');
  return;
}
await call.requestPermissions({
  permissions: [OwnCapability.SEND_AUDIO],
});

Approving permission requests
â€‹

Call hosts and moderators can approve permission requests from other users. Whenever a user requests a certain permission, a call.permission_request event will be emitted on the Call instance. You can listen to this event and approve the request.

import {
  PermissionRequestEvent,
  StreamCallEvent,
} from '@stream-io/video-react-sdk';

const call = client.call(type, id);
call.on('call.permission_request', async (event: StreamCallEvent) => {
  const request = event as PermissionRequestEvent;
  if (shouldApproveRequest(request)) {
    await call.grantPermissions(request.user.id, request.permissions);
  }
});

Moderation
â€‹

At any time, a moderator or host can decide to either grant or revoke certain permission to any participant.

import { OwnCapability } from '@stream-io/video-react-sdk';

const call = client.call(type, id);
await call.updateUserPermissions({
  user_id: 'demo-user',
  grant_permission: [OwnCapability.SEND_AUDIO, OwnCapability.SEND_VIDEO],
  revoke_permissions: [OwnCapability.SCREENSHARE],
});

// alternate API for granting user permissions:
await call.grantPermissions('demo-user', [
  OwnCapability.SEND_AUDIO,
  OwnCapability.SEND_VIDEO,
]);

// alternate API for revoking user permissions:
await call.revokePermissions('demo-user', [OwnCapability.SCREENSHARE]);


The end user would get notified via a WebSocket event with a type: call.permissions_updated. In the case of revoked permissions, the SDK would automatically stop publishing the appropriate tracks.

Muting participants
â€‹

In addition to granting or revoking permissions, a moderator or host can also mute a participant. This is a common scenario as quite often, participants may be a source of unwanted noise or distraction.

const call = client.call(type, id);
await call.muteUser('demo-user-id', 'audio');
await call.muteUser('demo-user-id', 'video');
await call.muteUser('demo-user-id', 'screenshare');

// or, mute in bulk
await call.muteUser(['demo-user-id', 'demo-user-id-2'], 'audio');

// or, muting self
await call.muteSelf('audio');

// or, muting others
await call.muteOthers('audio');

// or, mute all, including self.
await call.muteAllUsers('audio');


This operation doesn't revoke any permission, and the user would still be able to un-mute itself.

Ending call for everyone
â€‹

In some cases, a moderator or host may want to end the call for everyone.

const call = client.call(type, id);
await call.endCall();


This operation will emit call.ended event to every participant in the call. The SDK would automatically stop publishing any tracks and leave the call.

Ended calls can't be re-joined.

Feedback
Capabilities
â€‹

Every user connecting to a Stream Call has a set of Capabilities. The capabilities of the local user live in the state of the Call instance.

const call = client.call(type, id);
const { ownCapabilities } = call.state;


In our React Video SDK, you can use the useOwnCapabilities hook.

import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useOwnCapabilities } = useCallStateHooks();
const ownCapabilities = useOwnCapabilities();


Capabilities will have the type OwnCapability.

Feedback
Previous
Querying Calls
Next
Reactions & Custom Events
Did you find this page helpful?
Section:
Permissions & Moderation
SUBMIT
Conceptual overview
Roles
Call types
Capabilities
Permissions
Check permissions
Request permissions
Approving permission requests
Moderation
Muting participants
Ending call for everyone
Capabilities

Querying Calls

For many video calling, live stream, or audio rooms apps, you'll want to show:

Upcoming calls
Calls that are currently live
Popular live streams / audio rooms with a link to the recording

The SDK makes it easy to query calls.

Feedback
Sorting
â€‹

Sorting is supported on these fields below:

Field	Description
starts_at	When the call starts at
created_at	When the call was created
updated_at	When the call was updated
ended_at	When the call ended
type	The call type. Typically default, livestream etc...
id	The id for this call
cid	The cid for this call. IE: default:123
import { StreamVideoClient } from '@stream-io/video-react-sdk';

let client: StreamVideoClient;

await client.queryCalls({
  sort: [{ field: 'starts_at', direction: -1 }],
  limit: 10,
  watch: true,
});


It's possible to provide multiple sort parameters:

import { StreamVideoClient } from '@stream-io/video-react-sdk';

let client: StreamVideoClient;

await client.queryCalls({
  sort: [
    { field: 'starts_at', direction: -1 },
    { field: 'created_at', direction: 1 },
  ],
  limit: 10,
  watch: true,
});

Feedback
Filters
â€‹

You can filter on the following fields:

Field	Description
id	The id for this call
cid	The cid for this call. IE: default:123
team	The team id for the call.
type	The call type. Typically default, livestream etc...
created_by_user_id	The user id who created the call
created_at	When the call was created
updated_at	When the call was updated
ended_at	When the call ended
starts_at	When the call starts at
backstage	If the call is in backstage mode or not
members	Check if the call has these members listed
ongoing	Check if the call is ongoing or not
custom	You can query custom data using the "custom.myfield" syntax

Filter expressions support multiple match criteria, and it's also possible to combine filters. For more information, visit the filter operators guide.

Here are some example filters:

Calls that are about to start
â€‹
import { StreamVideoClient } from '@stream-io/video-react-sdk';

let client: StreamVideoClient;

const inNext30mins = 1000 * 60 * 60 * 30;
await client.queryCalls({
  filter_conditions: {
    starts_at: {
      $gt: new Date(Date.now() + inNext30mins).toISOString(),
    },
  },
  sort: [{ field: 'starts_at', direction: -1 }],
  limit: 10,
  watch: true,
});

Call filters on a custom property
â€‹
import { StreamVideoClient } from '@stream-io/video-react-sdk';

let client: StreamVideoClient;

await client.queryCalls({
  filter_conditions: { 'custom.color': 'red' },
  limit: 10,
  watch: true,
});

Calls that are live / currently have participants
â€‹
import { StreamVideoClient } from '@stream-io/video-react-sdk';

let client: StreamVideoClient;

await client.queryCalls({
  filter_conditions: { ongoing: true },
});

Calls the user has created or is a member of
â€‹
import { StreamVideoClient } from '@stream-io/video-react-sdk';

let client: StreamVideoClient;

await client.queryCalls({
  filter_conditions: {
    $or: [
      { created_by_user_id: '<user id>' },
      { members: { $in: ['<user id>'] } },
    ],
  },
  limit: 10,
  watch: true,
});

Feedback
Watching calls
â€‹

If you specify watch: true as an option, the SDK will create a subscription to the call data on the server and you'll be able to receive updates in real-time.

The server will send updates to the client when the call data changes (for example, members are updated, a call session has started, etc...). This is useful for showing a live preview of who is in the call or building a call dashboard.

Feedback
Pagination
â€‹

You can specify the page size using the limit option. The API response will include links to the previous/next pages. The following code example shows how pagination works:

import { StreamVideoClient } from '@stream-io/video-react-sdk';

let client: StreamVideoClient;

const inNext30mins = 1000 * 60 * 60 * 30;
const callQuery = {
  filter_conditions: {
    starts_at: {
      $gt: new Date(Date.now() + inNext30mins).toISOString(),
    },
  },
  sort: [{ field: 'starts_at', direction: -1 }],
  limit: 10,
  watch: true,
};

const response = await client.queryCalls(callQuery);

// Go to next page
await client.queryCalls({ ...callQuery, next: response.next });

// Go to prev page
await client.queryCalls({ ...callQuery, prev: response.prev });

Feedback
Previous
Call Types
Next
Permissions & Moderation
Did you find this page helpful?
Section:
Querying Calls
SUBMIT
Sorting
Filters
Calls that are about to start
Call filters on a custom property
Calls that are live / currently have participants
Calls the user has created or is a member of
Watching calls
Pagination

Call Types

The Video SDK uses a set of pre-defined call types that come with different default permissions and feature configurations. Depending on your use case you can also extend those and use custom types that suit your needs.

Let's start with some clarification on naming.

Call Type: 4 default call types come with a set of pre-defined user roles and capabilities that are assigned to these roles. These default types can be used but it's also possible to define custom call types via the dashboard.

User Role: Users can have different roles (note: one user can have multiple roles). Again, there are pre-defined user roles that each come with a certain set of capabilities. You can use the existing user roles or define custom ones via the dashboard.

Call Capabilities: Each participant of a call has certain capabilities (such as send-video or end-call). These are associated with a certain user role. The associations can be found further below and can also be customized via the dashboard.

Feedback
Call Types
â€‹

There are 4 pre-defined call types, these are:

default: simple 1-1 calls for larger group video calling with sensible defaults
audio_room: pre-configured for a workflow around requesting permissions in audio settings (speaking, etc.)
livestream: access to calls is granted to all authenticated users, useful in one-to-many settings (such as livestreaming)
development: should only be used for testing, permissions are open and everything is enabled (use carefully)

Before we go into more detail about what the different call types are for, let's take a look at some of the concrete permissions and settings that each call type comes with.

Each call type comes with a set of settings. One important concept is called backstage. It means that calls can be created but not directly joined. That means you can schedule a call. It would then have backstage enabled until you call goLive() with it.

Now, let's take a look at each of the call types in more detail.

Development
â€‹

The development call type has all the permissions enabled and can be used during development. It's not recommended to use this call type in production, since all the participants in the calls would be able to do everything (blocking, muting everyone, etc).

For these call types, backstage is not enabled, therefore you don't have to explicitly call goLive for the call to be started.

Default
â€‹

The default call type can be used for different video-calling apps, such as 1-1 calls, group calls, or meetings with multiple people. Both video and audio are enabled, and backstage is disabled. It has permissions settings in place, where admins and hosts have elevated permissions over other types of users.

TIP

The default type can be used in apps that use regular video calling. To learn more try our tutorial on building a video calling app.

Audio Room
â€‹

The audio_room call type is suitable for apps like Clubhouse or Twitter Spaces. It has a pre-configured workflow around requesting permissions to speak for regular listeners. Backstage is enabled, and new calls are going into backstage mode when created. You will need to explicitly call the goLive method to make the call active for all participants.

TIP

You can find out how to handle this and build an application with our Audio Room tutorial.

Livestream
â€‹

The livestream call type is configured to be used for live streaming apps. Access to calls is granted to all authenticated users, and backstage is enabled by default.

TIP

To build an example application for this you can take a look at our live streaming tutorial.

Feedback
Call type settings
â€‹

Each call comes with a number of settings. Depending on the type of call these are enabled or disabled.

NOTE

You can see a full table of which call type has which setting enabled in the next chapter.

First, we'll describe the different settings that exist in different categories.

Audio
â€‹
Setting Name	Type	Description
access_request_enabled	Boolean	When true users that do not have permission to this feature can request access for it
opus_dtx_enabled	Boolean	When true OPUS DTX is enabled
redundant_coding_enabled	Boolean	When true redundant audio transmission is enabled
mic_default_on	Boolean	When true the user will join with the microphone enabled by default
speaker_default_on	Boolean	When true the user will join with the audio turned on by default
default_device	String speaker or earpiece	The default audio device to use
Backstage
â€‹
Setting Name	Type	Description
enabled	Boolean	When backstage is enabled, calls will be in backstage mode when created and can be joined by users only after goLive is called
Video
â€‹
Setting Name	Type	Description
enabled	Boolean	Defines whether video is enabled for the call
access_request_enabled	Boolean	When true users that do not have permission to this feature can request access for it
camera_default_on	Boolean	When true, the camera will be turned on when joining the call
camera_facing	String front, back or external	When applicable, the camera that should be used by default
target_resolution	Target Resolution Object	The ideal resolution that video publishers should send

The target resolution object is an advanced resolution. Changing this from the default values can lead to poor performance. This is how you define it:

Setting Name	Type	Description
width	Number	The width in pixels
height	Number	The height in pixels
bitrate	Number	The bitrate
Screensharing
â€‹
Setting Name	Type	Description
enabled	Boolean	Defines whether screensharing is enabled
access_request_enabled	Boolean	When true users that do not have permission to this feature can request access for it
Recording
â€‹
Setting Name	Type	Description
mode	String available, disabled or auto-on	available â†’ recording can be requested
disabled â†’ recording is disabled
auto-on â†’ recording starts and stops automatically when one or multiple users join the call
quality	String audio-only, 360p, 480p, 720p, 1080p, 1440p	Defines the resolution of the recording
audio_only	boolean	If true the recordings will only contain audio
layout	object, for more information see the API docs	Configuration options for the recording application
Broadcasting
â€‹
Setting Name	Type	Description
enabled	Boolean	Defines whether broadcasting is enabled
hls	HLS Settings (object)	Settings for HLS broadcasting
HLS Settings
â€‹
Setting Name	Type	Description
enabled	Boolean	Defines whether HLS is enabled or not
auto_on	Boolean	When true HLS streaming will start as soon as users join the call
quality_tracks	String audio-only, 360p, 480p, 720p, 1080p, 1440p	The tracks to publish for the HLS stream (up to three tracks)
Geofencing
â€‹
Setting Name	Type	Description
names	List of one or more of these strings european_union, iran_north_korea_syria_exclusion, china_exclusion, russia_exclusion, belarus_exclusion, india, united_states, canada	The list of geofences that are used for the calls of these type

More information can be found in the API docs.

Transcription
â€‹
Setting Name	Type	Description
mode	String available, disabled or auto-on	Not implemented yet
closed_caption_mode	String	Not implemented yet
Ringing
â€‹
Setting Name	Type	Description
incoming_call_timeout_ms	Number	Defines how long the SDK should display the incoming call screen before discarding the call (in ms)
auto_cancel_timeout_ms	Number	Defines how long the caller should wait for others to accept the call before canceling (in ms)
Push Notifications Settings
â€‹
Setting Name	Type	Description
enabled	Boolean	
call_live_started	Event Notification Settings Object	The notification settings used for call_live_started events
session_started	Event Notification Settings Object	The notification settings used for session_started events
call_notification	Event Notification Settings Object	The notification settings used for call_notification events
call_ring	Event Notification Settings Object	The notification settings used for call_ring events

In order to define the event notification settings object, here is the structure of how it should look:

Setting Name	Type	Description
enabled	Boolean	Whether this object is enabled
apns	APNS Settings Object	The settings for APN notifications
APNS Settings Object
â€‹

Remote notifications can only be customized if your application implements a Notification Service Extension. For simple customizations, you can change the title and body fields at the call type level. Both title and body fields are handlebars templates with call and user objects available in their scope.

Setting Name	Type	Description
title	Template	The string template for the title field of the notification
body	Template	The string template for the body field of the notification
Defaults for call type settings
â€‹
	audio-room	default	livestream	development
Audio				
access_request_enabled	âœ…	âœ…	âŒ	âœ…
opus_dtx_enabled	âœ…	âœ…	âœ…	âœ…
redundant_coding_enabled	âœ…	âœ…	âœ…	âœ…
mic_default_on	âŒ	âœ…	âŒ	âœ…
speaker_default_on	âœ…	âœ…	âœ…	âœ…
default_device	speaker	earpiece	speaker	earpiece
Backstage				
enabled	âœ…	âŒ	âœ…	âŒ
Video				
enabled	âŒ	âœ…	âœ…	âœ…
access_request_enabled	âŒ	âœ…	âŒ	âœ…
target_resolution	N/A	Width: 2560
Height 1440
Bitrate 5000000	Width: 1920
Height: 1080
Bitrate 3000000	Width: 1920
Height 1080
Bitrate 3000000
camera_default_on	âŒ	âœ…	âœ…	âœ…
camera_facing	front	front	front	front
Screensharing				
enabled	âŒ	âœ…	âœ…	âœ…
access_request_enabled	âŒ	âœ…	âŒ	âœ…
Recording				
mode	available	available	available	available
quality	720p	720p	720p	720p
Broadcasting				
enabled	âœ…	âœ…	âœ…	âœ…
hls.auto_on	âŒ	âŒ	âŒ	âŒ
hls.enabled	available	available	available	available
hls.quality_tracks	[720p]	[720p]	[720p]	[720p]
Geofencing				
names	[]	[]	[]	[]
Transcriptions				
mode	available	available	available	available
Ringing				
incoming_call_timeout_ms	0	15000	0	15000
auto_cancel_timeout_ms	0	15000	0	15000
Feedback
User roles
â€‹

There are 5 pre-defined user roles, these are:

user
moderator
host
admin
call-member

As mentioned before each user role is associated with a set of call capabilities. You can access the default roles and their capabilities in the Stream Dashboard.

In general, it makes sense to have a solid setup of roles as it makes handling permissions and requests easier.

Feedback
Call Capabilities
â€‹

A capability defines the actions that a certain user is allowed to perform on a call. There are many different available (see a full list in the next chapter). Each user has a certain set of capabilities attached to them. You can change these default capabilities in the dashboard. It is also possible to dynamically change these.

That means that if a user has permission to assign new capabilities they can assign them to other users. This is our approach to an effective permission system.

TIP

If you want to learn more about doing this, head over to the Permissions and Capabilities chapter.

Default call capabilities
â€‹

When a call is fetched from the API by a user, the response includes the list of actions that the user is allowed to perform on the call.

These are the following:

join-call
read-call
create-call
join-ended-call
join-backstage
update-call
update-call-settings
screenshare
send-video
send-audio
start-record-call
stop-record-call
start-broadcast-call
stop-broadcast-call
end-call
mute-users
update-call-permissions
block-users
create-reaction
pin-for-everyone
remove-call-member
start-transcription-call
stop-transcription-call
Feedback
Previous
Screen Sharing
Next
Querying Calls
Did you find this page helpful?
Section:
Call Types
SUBMIT

Screen Sharing
Feedback
Screen Sharing
â€‹
Start/Stop Screen Sharing
â€‹
await call.screenShare.toggle();

// or
await call.screenShare.enable();
await call.screenShare.disable();

// alternatively
import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useScreenShareState } = useCallStateHooks();
const { screenShare } = useScreenShareState();
await screenShare.toggle();

Screen Sharing Status
â€‹

Here is how you can access the status of screen sharing:

import { useCallStateHooks } from '@stream-io/video-react-sdk';

call.screenShare.state.status; // enabled, disabled or undefined

// or, if you want to subscribe to changes
const { useScreenShareState } = useCallStateHooks();
const { status } = useScreenShareState();

console.log('Screen sharing is:', status === 'enabled' ? 'active' : 'inactive');

Screen Sharing Settings
â€‹

The behavior of the screen share video track can be customized, and a few parameters can be set:

call.screenShare.setSettings({
  maxFramerate: 15, // will be clamped between 1 and 15 fps
  maxBitrate: 1500000, // will use at most 1.5Mbps
});

await call.screenShare.enable();

Render Screen Share
â€‹

Our SDK provided ParticipantView component can automatically render the screen share video track.

Feedback
Screen Share Audio
â€‹
Start/Stop Screen Share Audio
â€‹
// enable it
call.screenShare.enableScreenShareAudio();

// publish video and audio (if available, and supported by the browser)
await call.screenShare.enable();

// disable it
call.screenShare.disableScreenShareAudio();

Play Screen Share Audio
â€‹

Our SDK provided ParticipantView component can automatically play the screen share audio track.

Caveats
â€‹

Screen Share Audio has limited support across browsers and platforms. For most up-to-date information, please take a look at Browser Compatibility.

In addition to that, there are a few caveats that you should be aware of:

On Windows, the entire system audio can be captured, but on MacOS and Linux, only the audio of a tab can be captured.
Feedback
Previous
Camera & Microphone
Next
Call Types
Did you find this page helpful?
Section:
Screen Sharing
SUBMIT
Screen Sharing
Start/Stop Screen Sharing
Screen Sharing Status
Screen Sharing Settings
Render Screen Share
Screen Share Audio
Start/Stop Screen Share Audio
Play Screen Share Audio
Caveats

Camera & Microphone

Handling audio and video devices in a web application means working with MediaStream, MediaDeviceInfo and other WebRTC API objects. We did our best to hide this complexity through a set of APIs exposed as through a call instance, or a set of utility hooks.

Feedback
Camera management
â€‹
Call settings
â€‹

The default state of the camera is determined by the call type settings:

import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useCallSettings } = useCallStateHooks();
const settings = useCallSettings();

console.log(settings?.video.camera_default_on);

Start-stop camera
â€‹
import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useCameraState } = useCallStateHooks();
const { camera, isMute } = useCameraState();

console.log(`Camera is ${isMute ? 'off' : 'on'}`);
await camera.toggle();

// or, alternatively
await camera.enable();
await camera.disable();

List and select devices
â€‹
import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useCameraState } = useCallStateHooks();
const { camera, selectedDevice, devices } = useCameraState();

console.log('current camera id:', selectedDevice);
console.log('available devices:', devices);

const preferredDevice = devices.find((d) => d.label === 'My Camera');
await camera.select(preferredDevice.deviceId);

Camera permissions
â€‹
import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useCameraState } = useCallStateHooks();
const { hasBrowserPermission } = useCameraState();

if (hasBrowserPermission) {
  console.log('User has granted camera permissions!');
} else {
  console.log('User has denied or not granted camera permissions!');
}

Lobby preview
â€‹

Here is how to set up a video preview displayed before joining the call:

import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useCameraState } = useCallStateHooks();
const { camera, mediaStream } = useCameraState();

// will turn on the camera
await camera.enable();

// play the video preview
<video srcObject={mediaStream} autoPlay muted />;


Alternatively, you can use the SDK-provided VideoPreview component.

Feedback
Microphone management
â€‹
Call settings
â€‹

The default state of the microphone is determined by the call settings:

import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useCallSettings } = useCallStateHooks();
const settings = useCallSettings();

console.log(settings?.audio.mic_default_on);

Start-stop microphone
â€‹
import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useMicrophoneState } = useCallStateHooks();
const { microphone, isMute } = useMicrophoneState();

console.log(`Microphone is ${isMute ? 'off' : 'on'}`);
await microphone.toggle();

// or, alternatively
await microphone.enable();
await microphone.disable();

List and select devices
â€‹
import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useMicrophoneState } = useCallStateHooks();
const { microphone, selectedDevice, devices } = useMicrophoneState();

console.log('current mic-id:', selectedDevice);
console.log('available devices:', devices);

const preferredDevice = devices.find((d) => d.label === 'My Mic');
await microphone.select(preferredDevice.deviceId);

Microphone permissions
â€‹
import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useMicrophoneState } = useCallStateHooks();
const { hasBrowserPermission } = useMicrophoneState();

if (hasBrowserPermission) {
  console.log('User has granted microphone permissions!');
} else {
  console.log('User has denied or not granted microphone permissions!');
}

Speaking while muted detection
â€‹

Our SDK provides a mechanism that can detect whether the user started to speak while being muted. Through this mechanism, you can display a notification to the user, or apply any custom logic.

import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useMicrophoneState } = useCallStateHooks();
const { isSpeakingWhileMuted } = useMicrophoneState();

if (isSpeakingWhileMuted) {
  // your custom logic comes here
  console.log('You are speaking while muted!');
}

Feedback
Speaker management
â€‹
Browser support
â€‹

Selecting an audio output device for the call isn't supported by all browsers, and this is how you can check the availability:

import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useSpeakerState } = useCallStateHooks();
const { isDeviceSelectionSupported } = useSpeakerState();

console.log('is speaker selection supported:', isDeviceSelectionSupported);

List and select devices
â€‹
import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useSpeakerState } = useCallStateHooks();
const { speaker, selectedDevice, devices } = useSpeakerState();

console.log('current mic-id:', selectedDevice);
console.log('available devices:', devices);

const preferredDevice = devices.find((d) => d.label === 'My Speakers');
await speaker.select(preferredDevice.deviceId);

Set master output volume
â€‹
import { useCallStateHooks } from '@stream-io/video-react-sdk';

const { useSpeakerState } = useCallStateHooks();
const { speaker } = useSpeakerState();

speaker.setVolume(0.5); // 0.5 is 50% of the maximum volume

Feedback
Persisting user's device preferences
â€‹

For user's convenience, you might want to persist the user's choices for the camera, microphone and speaker devices across sessions.

There are multiple ways on how to achieve this, and our SDK provides one utility hook that can help you with this by utilizing localStorage under the hood.

import {
  StreamVideo,
  StreamCall,
  usePersistedDevicePreferences,
} from '@stream-io/video-react-sdk';

export const MyApp = () => {
  return (
    <StreamVideo client={client}>
      <StreamCall call={call}>
        <MyCallShell />
      </StreamCall>
    </StreamVideo>
  );
};

const MyCallShell = () => {
  usePersistedDevicePreferences('my-custom-preference-key');
  return <div>...</div>;
};

Feedback
Previous
Call & Participant State
Next
Screen Sharing
Did you find this page helpful?
Section:
Camera & Microphone
SUBMIT
Camera management
Call settings
Start-stop camera
List and select devices
Camera permissions
Lobby preview
Microphone management
Call settings
Start-stop microphone
List and select devices
Microphone permissions
Speaking while muted detection
Speaker management
Browser support
List and select devices
Set master output volume
Persisting user's device preferences

Call & Participant State

You can access call, participant and client state using hooks. These hooks are reactive (their value is updated on WebSocket events and API calls).

Feedback
Call state
â€‹

To observe call state you need to provide a Call instance to the StreamCall component.

Let's see an example where we use the useCall, useCallCallingState and useParticipants hooks to display some basic information about the call:

import {
  Call,
  StreamCall,
  useCall,
  useCallStateHooks,
} from '@stream-io/video-react-sdk';

export default function App() {
  let call: Call;

  return (
    <StreamCall call={call}>
      <MyCallUI />
    </StreamCall>
  );
}

const MyCallUI = () => {
  const call = useCall();

  const { useCallCallingState, useParticipants } = useCallStateHooks();
  const callingState = useCallCallingState();
  const participants = useParticipants();

  return (
    <div>
      <div>Call: {call?.cid}</div>
      <div>State: {callingState}</div>
      <div>Participants: {participants.length}</div>
    </div>
  );
};


This approach makes it possible to access the call state and be notified about changes anywhere in your application without having to manually subscribe to WebSocket events.

The StreamCall component uses the StreamCallProvider under the hood.

Here is an excerpt of the available call state hooks:

Name	Description
useCall	The Call instance that is registered with StreamCall. You need the Call instance to initiate API calls.
useCallBlockedUserIds	The list of blocked user IDs.
useCallCallingState	Provides information about the call state. For example, RINGING, JOINED or RECONNECTING.
useCallCreatedAt	The time the call was created.
useCallCreatedBy	The user that created the call.
useCallCustomData	The custom data attached to the call.
useCallEgress	The egress information of the call.
useCallEndedBy	The user that ended the call.
useCallIngress	The ingress information of the call.
useCallMembers	The list of call members
useCallSession	The information for the current call session.
useCallSettings	The settings of the call.
useCallStartedAt	The actual start time of the current call session.
useCallStartsAt	The scheduled start time of the call.
useCallStatsReport	When stats gathering is enabled, this observable will emit a new value at a regular (configurable) interval.
useCallThumbnail	The thumbnail of the call.
useCallUpdatedAt	The time the call was last updated.
useCameraState	The camera state of the local participant.
useDominantSpeaker	The participant that is the current dominant speaker of the call.
useHasOngoingScreenShare	It will return true if at least one participant is sharing their screen.
useHasPermissions	Returns true if the local participant has all the given permissions.
useIsCallHLSBroadcastingInProgress	It's true if the call is being broadcasted in HLS mode.
useIsCallLive	It's true if the call is currently live.
useIsCallRecordingInProgress	It's' true if the call is being recorded.
useIsCallTranscribingInProgress	It's true if the call is being transcribed.
useMicrophoneState	The microphone state of the local participant.
useOwnCapabilities	The capabilities of the local participant.
useScreenShareState	The screen share state of the local participant.
useSpeakerState	The speaker state of the local participant.

In your IDE of choice, you can see the full list if you destructure the useCallStateHooks object:

import { useCallStateHooks } from '@stream-io/video-react-sdk';

const {
  useCallMembers,
  useDominantSpeaker,
  useParticipants,
  useLocalParticipant,
  useIsCallRecordingInProgress,
  // ...
} = useCallStateHooks();

Feedback
Participant state
â€‹

If you want to display information about the joined participants of the call you can use these hooks:

Name	Description
useLocalParticipant	The local participant is the logged-in user.
useRemoteParticipants	All participants except the local participant.
useParticipants	All participants, including local and remote participants.
useParticipantCount	The approximate participant count of the active call. This includes the anonymous users as well, it is computed on the server-side.
useAnonymousParticipantCount	The approximate participant count of anonymous users in the active call.
import { useCallStateHooks, StreamCall } from '@stream-io/video-react-sdk';

export default function App() {
  let call: call;

  return (
    <StreamCall call={call}>
      <MyCallUI />
    </StreamCall>
  );
}

const MyCallUI = () => {
  const { useLocalParticipant, useParticipantCount } = useCallStateHooks();
  const participantCount = useParticipantCount();
  const localParticipant = useLocalParticipant();

  return (
    <div>
      <div>Number of participants: {participantCount}</div>
      <div>Session ID: {localParticipant.sessionId}</div>
    </div>
  );
};


The StreamVideoParticipant object contains the following information:

Name	Description
user	The user object for this participant.
publishedTracks	The track types the participant is currently publishing
joinedAt	The time the participant joined the call.
connectionQuality	The participant's connection quality.
isSpeaking	It's true if the participant is currently speaking.
isDominantSpeaker	It's true if the participant is the current dominant speaker in the call.
audioLevel	The audio level of the participant.
audioStream	The published audio MediaStream.
videoStream	The published video MediaStream.
screenShareStream	The published screen share MediaStream.
screenShareAudioStream	The published screen share audio MediaStream.
isLocalParticipant	It's true if the participant is the local participant.
pin	Holds pinning information.
reaction	The last reaction this user has sent to this call.
viewportVisibilityState	The viewport visibility state of the participant.
Feedback
Client state
â€‹

To observe client state you need to provide a StreamVideoClient instance to the StreamVideo context provider. If you want to observe the connected user you can use the useConnectedUser hook.

Let's see an example:

import {
  useConnectedUser,
  StreamVideoClient,
} from '@stream-io/video-react-sdk';

export default function App() {
  let client: StreamVideoClient;

  return (
    <StreamVideo client={client}>
      <MyHeader />
    </StreamVideo>
  );
}

const MyHeader = () => {
  const user = useConnectedUser();
  return <div>{user ? `Logged in: ${user.name}` : 'Logged out'}</div>;
};


This approach makes it possible to access the client state and be notified about changes anywhere in your application without having to manually subscribe to WebSocket events.

Here are the list of client-state hooks:

Name	Description
useStreamVideoClient	The StreamVideoClient instance.
useConnectedUser	Returns the connected user.
useCalls	A list of all notifications about created calls. These calls can be outgoing (I have called somebody) or incoming (somebody has called me).

The UserResponse contains the following properties:

Name	Description
created_at	The time the user was created.
custom	Custom user data.
deleted_at	The time the user was deleted.
devices	The registered push notification devices of the user.
id	The id of the user.
image	The profile image of the user.
name	The name of the user.
role	The role of the user.
teams	The teams the user belongs to.
updated_at	The time when the user was updated.
Feedback
Previous
Joining & Creating Calls
Next
Camera & Microphone
Did you find this page helpful?
Section:
Call & Participant State
SUBMIT
Call state
Participant state
Client state

Joining & Creating Calls

This guide shows how to create, join, leave, and end call rooms and ring calls.

Feedback
Call
â€‹
Create and join a call
â€‹

You create a call by specifying a call type and a call id.

const callType = 'default';
const callId = 'test-call';
await client.call(callType, callId).join({ create: true });


The call type controls which features are enabled, and sets up permissions.

One of the flags you can provide there is create. Set this to true if you want to enable creating new calls. Set it to false if you only want to allow joining existing calls.

See all possible options at the Call creation options section

If you don't want to join a call, just create one, you can use the getOrCreate method:

const callType = 'default';
const callId = 'test-call';
await client.call(callType, callId).getOrCreate();


See all possible options at the Call creation options section

Join with mic and camera on or off
â€‹

You can override the default mic and camera settings before you join a call. Typically, you should configure this in your Lobby view:

const call = client.call('default', 'test-call');

// enable mic and camera
await call.camera.enable();
await call.microphone.enable();

// alternatively, you can disable them
await call.camera.disable();
await call.microphone.disable();

// and then join the call
await call.join();

Leave call
â€‹

To leave a call, you can use the leave method:

await call.leave();

End call
â€‹

Ending a call requires a special permission. This action terminates the call for everyone.

await call.endCall();


Only users with special permission can join an ended call.

Feedback
Ring call
â€‹
Create call
â€‹

To create a ring call, we need to set the ring flag to true and provide the list of members we want to call. It is important to note that the caller should also be included in the list of members.

await client.call('default', 'test-outgoing-call').getOrCreate({

  ring: true,

  data: {
    members: [

      { user_id: 'myself' },

      { user_id: 'my friend' },
    ],
  },
});


See all possible options at the Call creation options section

This step will start the signaling flow. The caller will automatically join the call once the first callee accepts the call. The calling will automatically stop if all callee rejects the call.

Watch for incoming and outgoing calls
â€‹

The easiest way to watch for incoming and outgoing calls is to use the useCalls hook.

import { useCalls, CallingState } from '@stream-io/video-react-sdk';

export const MyCallUI = () => {
  const calls = useCalls();

  // handle incoming ring calls
  const incomingCalls = calls.filter(
    (call) =>
      call.isCreatedByMe === false &&
      call.state.callingState === CallingState.RINGING,
  );

  const [incomingCall] = incomingCalls;
  if (incomingCall) {
    // render the incoming call UI
    return <MyIncomingCallUI call={incomingCall} />;
  }

  // handle outgoing ring calls
  const outgoingCalls = calls.filter(
    (call) =>
      call.isCreatedByMe === true &&
      call.state.callingState === CallingState.RINGING,
  );

  const [outgoingCall] = outgoingCalls;
  if (outgoingCall) {
    // render the outgoing call UI
    return <MyOutgoingCallUI call={outgoingCall} />;
  }

  return null;
};


You can also check the sample integration in the following CodeSandboxes:

Caller side
Callee side
Canceling a call
â€‹

A caller can cancel an outgoing call until the first callee accepts the call. Canceling a call will stop the signaling flow.

await call.leave();


Please note that calling call.leave() after joining the call won't stop the signaling flow.

Accepting a call
â€‹

A callee can accept or reject an incoming call. To accept and join the call:

await call.join();


Please note that it's possible to join multiple calls. If you only want to allow one active call, you must leave joined calls before accepting an incoming call.

Rejecting a call
â€‹

A callee can accept or reject an incoming call. To reject the call:

await call.leave({ reject: true });

Leave call
â€‹

To leave a joined call, you can use the leave method:

await call.leave();

End call
â€‹

Ending a call requires a special permission. This action terminates the call for everyone.

await call.endCall();

Feedback
Call creation options
â€‹

The following options are supported when creating a call:

Option	Description	Default
members	A list of members to add to this call. You can specify the role and custom data on these members	-
custom	Any custom data you want to store	-
settings	You can overwrite certain call settings for this specific call. This overwrites the call type standard settings	-
startsAt	When the call will start. Used for calls scheduled in the future, livestreams, audio rooms etc	-
team	Restrict the access to this call to a specific team	-
ring	If you want the call to ring for each member	false
Restricting access
â€‹

You can restrict access to a call by tweaking the Call Type permissions and roles. A typical use case is to restrict access to a call to a specific set of users -> call members.

Step 1: Set up the roles and permissions
â€‹

On our dashboard, navigate to the Video & Audio -> Roles & Permissions section and select the appropriate role and scope. In this example, we will use my-call-type scope.

By default, all users unless specified otherwise, have the user role.

We start by removing the JoinCall permission from the user role for the my-call-type scope. It will prevent regular users from joining a call of this type.

Next, let's ensure that the call_member role has the JoinCall permission for the my-call-type scope. It will allow users with the call_member role to join a call of this type.

Once this is set, we can proceed with setting up a call instance.

Step 2: Set up the call
â€‹
const call = client.call('my-call-type', 'my-call-id');
await call.getOrCreate({
  data: {
    members: [
      // please note the `role` property
      { user_id: 'alice', role: 'call_member' },
      { user_id: 'bob', role: 'call_member' },
    ],
  },
});

// and if necessary, to grant access to more users
await call.updateCallMembers({
  update_members: [{ user_id: 'charlie', role: 'call_member' }],
});

// or, to remove access from some users
await call.updateCallMembers({
  remove_members: ['charlie'],
});

Feedback
Previous
Client & Authentication
Next
Call & Participant State
Did you find this page helpful?
Section:
Joining & Creating Calls
SUBMIT
Call
Create and join a call
Join with mic and camera on or off
Leave call
End call
Ring call
Create call
Watch for incoming and outgoing calls
Canceling a call
Accepting a call
Rejecting a call
Leave call
End call
Call creation options
Restricting access

Quickstart

This quickstart gives you a quick overview of how Stream's video SDKs work.

Feedback
Client setup & Calls
â€‹

Create an instance of StreamVideoClient that will establish WebSocket connection by connecting a user.

Next you create a call object and join the call. We'll specify create: true to create the call if it doesn't exist.

import {
  StreamCall,
  StreamVideo,
  StreamVideoClient,
  User,
} from '@stream-io/video-react-sdk';

const apiKey = 'your-api-key';
const userId = 'user-id';
const token = 'authentication-token';
const user: User = { id: userId };

const client = new StreamVideoClient({ apiKey, user, token });
const call = client.call('default', 'my-first-call');
call.join({ create: true });

export const App = () => {
  return (
    <StreamVideo client={client}>
      <StreamCall call={call}>/* My Video UI */</StreamCall>
    </StreamVideo>
  );
};


default is a call type. There are 4 built-in call types and you can also create your own. The call type controls the permissions and which features are enabled.

The second argument is the call id. Call IDs can be reused, meaning that it's possible to join a call with the same id multiple times (for example, for recurring meetings).

Feedback
Rendering video
â€‹

The call's state can be accessed using hooks, all exposed through the top-level useCallStateHooks hook.

You'll often work with useParticipants hook. Have a look below for a basic example of how to render the video of all participants:

import { useCallStateHooks, ParticipantView } from '@stream-io/video-react-sdk';

export const MyVideoUI = () => {
  const { useParticipants } = useCallStateHooks();
  const participants = useParticipants();
  return (
    <>
      {participants.map((p) => (
        <ParticipantView participant={p} key={p.sessionId} />
      ))}
    </>
  );
};


The participant object contains all essential information to render videos, such as audio/video tracks, user information, audio/video enabled, etc. sessionId uniquely identifies a participant in a call.

More information about state management can be found in the Call & Participant State guide.

Feedback
Camera & Microphone
â€‹

Most video apps will show buttons to mute/unmute the audio or video. The example below shows how to use the camera:

import { useCallStateHooks } from '@stream-io/video-react-sdk';

export const MyVideoButton = () => {
  const { useCameraState } = useCallStateHooks();
  const { camera, isMute } = useCameraState();
  return (
    <button onClick={() => camera.toggle()}>
      {isMute ? 'Turn on camera' : 'Turn off camera'}
    </button>
  );
};

export const MyMicrophoneButton = () => {
  const { useMicrophoneState } = useCallStateHooks();
  const { microphone, isMute } = useMicrophoneState();
  return (
    <button onClick={() => microphone.toggle()}>
      {isMute ? 'Turn on microphone' : 'Turn off microphone'}
    </button>
  );
};


More information about this topic can be found in the Camera & Microphone guide.

Feedback
UI Components
â€‹

The goal of this library is to make it easy to build any type of video/calling experience. You have a few options for the UI:

Build your own UI components using the state as shown above.
Use our library of built-in components.
Mix & Match between your own and built-in components.

The built-in components you can customize using theming and props. If you decide to build your own components we have a UI Cookbook section to help you get started.

Let's see an example where we set up the UI using built-in components:

Set up theming using the StreamTheme provider
Choose a UI layout from the SDK-provided ones, such as <SpeakerLayout>, which provides a layout suitable for speaker-focused video calls.
Additionally, hook in the default <CallControls /> component to enable call control functionalities (such as mute, hang up, etc.).
import {
  CallControls,
  SpeakerLayout,
  StreamCall,
  StreamTheme,
  StreamVideo,
} from '@stream-io/video-react-sdk';

import '@stream-io/video-react-sdk/dist/css/styles.css';

export const MyApp = () => {
  // Assuming you have the 'client' and 'call' created
  return (
    <StreamVideo client={client}>
      <StreamCall call={call}>
        <StreamTheme>
          <SpeakerLayout />
          <CallControls />
        </StreamTheme>
      </StreamCall>
    </StreamVideo>
  );
};

Feedback
See it in action
â€‹

We have prepared a CodeSandbox example that demonstrates the above steps in action. Feel free to play around with it and explore the SDK's features.

Feedback
Previous
Installation
Next
Client & Authentication
Did you find this page helpful?
Section:
Quickstart
SUBMIT
Client setup & Calls
Rendering video
Camera & Microphone
UI Components
See it in action

Client & Authentication
Feedback
Client & Auth
â€‹

Before joining a call, it is necessary to set up the video client. Here's a basic example:

import { StreamVideoClient, User } from '@stream-io/video-react-sdk';

const user: User = {
  id: 'sara',
};

const client = new StreamVideoClient({ apiKey, token, user });

The API Key can be found in your dashboard.
The user can be either authenticated, anonymous or guest.
Note: You can store custom data on the user object, if required.

Typically, you'll want to initialize the client when your application loads and use a context provider to make it available to the rest of your application.

Feedback
Generating a token
â€‹

Tokens need to be generated server side. You can use our server side SDKs to quickly add support for this. Typically you integrate this into the part of your codebase where you login or register users. The tokens provide a way to authenticate a user or give access to a specific set of calls.

NOTE

For development purposes, you can use our Token Generator.

Feedback
Different types of users
â€‹
Authenticated users are users that have an account on your app.
Guest users are temporary user accounts. You can use it to temporarily give someone a name and image when joining a call.
Anonymous users are users that are not authenticated. It's common to use this for watching a livestream or similar where you aren't authenticated.

This example shows the client setup for a guest user:

import { StreamVideoClient, User } from '@stream-io/video-react-sdk';

const user: User = {
  id: 'jack-guest',
  type: 'guest',
};

const client = new StreamVideoClient({ apiKey, user });


And here's an example for an anonymous user

import { StreamVideoClient, User } from '@stream-io/video-react-sdk';

const user: User = {
  type: 'anonymous',
};

const client = new StreamVideoClient({ apiKey, user });

Feedback
Client options
â€‹
token
or
tokenProvider
â€‹

To authenticate users you can either provide a string token or a tokenProvider function that returns Promise<string>. If you use the tokenProvider the SDK will automatically call the provider whenever the token is expired.

Logging
â€‹

You can configure the log level and the logger method used by the SDK.

The default log level is warn, other options are: trace, debug, info, and error.

The default logger method will log to the browser's console.

import { StreamVideoClient, Logger } from '@stream-io/video-react-sdk';

const myLogger: Logger = (logLevel, message, ...args) => {
  // Do something with the log message
};

const client = new StreamVideoClient({
  apiKey,
  token,
  user,
  options: {
    logLevel: 'info',
    logger: myLogger,
  },
});


Here is an example showing a basic Sentry integration:

import { LogLevel, Logger, logToConsole } from '@stream-io/video-react-sdk';
import * as Sentry from '@sentry/nextjs';

const logLevelMapping = new Map<LogLevel, Sentry.SeverityLevel>();
logLevelMapping.set('debug', 'debug');
logLevelMapping.set('info', 'info');
logLevelMapping.set('warn', 'warning');
logLevelMapping.set('error', 'error');

export const customSentryLogger: Logger = (
  logLevel: LogLevel,
  message: string,
  ...args: unknown[]
) => {
  if (logLevel === 'warn' || logLevel === 'error') {
    Sentry.captureEvent({
      level: logLevelMapping.get(logLevel),
      extra: args,
    });
  }

  // Call the SDK's default log method
  logToConsole(logLevel, message, { data: 'some data' });
};

Feedback
StreamVideo context provider
â€‹

You can use the StreamVideo context provider to make the SDK client available to the rest of the application. We also use the tokenProvider to show how to perform auth server-side.

import { useState } from 'react';
import { StreamVideo, StreamVideoClient } from '@stream-io/video-react-sdk';
export const App = () => {
  const [client] = useState(() => {
    const user = {
      id: '<id>',
      name: '<name>',
    };
    const tokenProvider = () => Promise.resolve('<token>');
    return new StreamVideoClient({
      apiKey,
      tokenProvider,
      user,
    });
  });

  return (
    <StreamVideo client={client}>
      <MyVideoApp />
    </StreamVideo>
  );
};

Feedback
Previous
Quickstart
Next
Joining & Creating Calls
Did you find this page helpful?
Section:
Client & Authentication
SUBMIT
Client & Auth
Generating a token
Different types of users
Client options
token or tokenProvider
Logging
StreamVideo context provider

Installation

The installation of the packages for the Stream Video React SDK can be either done with yarn or npm.

For yarn:

yarn add @stream-io/video-react-sdk


For npm:

npm install @stream-io/video-react-sdk

Feedback
Previous
Introduction
Next
Quickstart
Did you find this page helpful?
Section:
Installation
SUBMIT

Introduction

Welcome to the Stream React Video SDK - a comprehensive toolkit designed to help you swiftly implement features such as video calling, audio calling, audio rooms, and livestreaming within your app. Our goal is to ensure an optimal developer experience that enables your application to go live within days.

Our React Video SDK comes with user-friendly UI components and React hooks and context providers, making your development process seamless. Moreover, all calls are routed through Stream's global edge network, thereby ensuring lower latency and higher reliability due to proximity to end users.

If you're new to Stream Video SDK, we recommend starting with the following three tutorials:

Video & Audio Calling Tutorial
Audio Room Tutorial
Livestream Tutorial

After the tutorials, the documentation explains how to use:

Core concepts such as initiating a call, switching the camera view, and more
Effective utilization of our UI components
Insights on building your own UI with our UI Cookbook

It also explains advanced features such as:

Picture in picture support
Ringing
Recording
Broadcasting
Requesting & Granting permissions
Audio & Video Filters

If you feel like anything is missing or could be improved, please don't hesitate to contact us. We're happy to help.

Feedback
Next
Installation
Did you find this page helpful?
Section:
Introduction
SUBMIT